<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Jira Focus Web</title>
  <style>
    :root {
      --bg: #edf2f8;
      --bg-soft: #f8fbff;
      --card: #ffffff;
      --line: #d5e2f1;
      --line-strong: #b9cde2;
      --text: #132538;
      --muted: #567089;
      --primary: #0d5ea8;
      --primary-dark: #0a4d89;
      --warn: #87500a;
      --danger: #ab2525;
      --ok: #157247;
      --shadow: 0 10px 28px rgba(14, 42, 74, 0.08);
    }
    * {
      box-sizing: border-box;
      min-width: 0;
    }
    html, body {
      max-width: 100%;
      overflow-x: hidden;
    }
    body {
      margin: 0;
      padding: 12px;
      font-family: "Trebuchet MS", "Gill Sans", "Verdana", sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 8% -20%, #ffffff 0, var(--bg-soft) 34%, transparent 58%),
        linear-gradient(180deg, #eef3f9 0%, var(--bg) 100%);
    }
    .app {
      display: grid;
      gap: 12px;
      width: 100%;
      max-width: 1320px;
      margin: 0 auto;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .topbar {
      border: 0;
      background: linear-gradient(120deg, #0e518f 0%, #1973ba 70%, #2f8bcb 100%);
      color: #ffffff;
    }
    .topbar h2 {
      color: #ffffff;
      letter-spacing: 0.2px;
    }
    .topbar .muted { color: rgba(235, 245, 255, 0.9); }
    .topbar .pill {
      color: #ffffff;
      border-color: rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.18);
      backdrop-filter: blur(3px);
    }
    .topbar .pill.ok {
      color: #ffffff;
      border-color: rgba(196, 255, 215, 0.65);
      background: rgba(55, 154, 95, 0.45);
    }
    .topbar .btn {
      color: #ffffff;
      border-color: rgba(255, 255, 255, 0.45);
      background: rgba(255, 255, 255, 0.16);
    }
    .topbar .btn:hover:not(:disabled) {
      border-color: rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.24);
    }
    .topbar .btn.danger {
      color: #ffffff;
      border-color: rgba(255, 209, 209, 0.75);
      background: rgba(173, 46, 46, 0.45);
    }
    .grid2 { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .grid3 { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
    .activity-config-grid {
      display: grid;
      grid-template-columns: minmax(220px, 2fr) minmax(220px, 2fr) minmax(170px, 1.2fr) minmax(120px, 1fr);
      gap: 10px;
      align-items: end;
      margin-top: 8px;
    }
    .board-head {
      padding-top: 10px;
      padding-bottom: 10px;
    }
    .board-ticket-picker {
      width: 100%;
      max-width: 100%;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.35fr) minmax(320px, 1fr);
      gap: 10px;
      align-items: start;
      margin-top: 10px;
    }
    .dashboard-grid > .card { min-height: 270px; }
    .panel-timeline { grid-column: 1; grid-row: 1; }
    .panel-suggestion { grid-column: 2; grid-row: 1; }
    .panel-comments { grid-column: 1; grid-row: 2; }
    .panel-worklogs { grid-column: 2; grid-row: 2; }
    .panel-comments .comments { max-height: 460px; }
    .panel-worklogs .tbl-wrap { max-height: 460px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    h2, h3, h4 { margin: 0 0 8px 0; }
    h3 { font-size: 17px; letter-spacing: 0.15px; }
    .muted { color: var(--muted); font-size: 12px; }
    .pill {
      display: inline-flex;
      align-items: center;
      max-width: 100%;
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 5px 11px;
      font-size: 12px;
      color: var(--muted);
      background: #fff;
      white-space: normal;
      overflow-wrap: anywhere;
    }
    .pill.ok { color: var(--ok); border-color: #a6d8bb; background: #edfbf3; }
    .pill.warn { color: var(--warn); border-color: #efcd8f; background: #fff7e8; }
    .btn {
      border: 1px solid #c4d3e3;
      border-radius: 9px;
      background: linear-gradient(180deg, #ffffff 0%, #f4f8fc 100%);
      color: var(--text);
      padding: 8px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      border-color: var(--line-strong);
      box-shadow: 0 4px 10px rgba(20, 43, 70, 0.08);
    }
    .btn:disabled { opacity: .55; cursor: not-allowed; }
    .btn.primary {
      background: linear-gradient(180deg, #1472bf 0%, var(--primary) 100%);
      border-color: var(--primary-dark);
      color: #fff;
    }
    .btn.warn { background: #fff7e8; border-color: #efcd8f; color: var(--warn); }
    .btn.danger { background: #fff1f1; border-color: #e6b2b2; color: var(--danger); }
    .inp, .sel, .txt {
      width: 100%;
      border: 1px solid #c5d4e6;
      border-radius: 9px;
      padding: 8px 10px;
      font-size: 13px;
      background: #fff;
      color: var(--text);
    }
    .inp[readonly] {
      background: #f4f8fd;
      color: #2b445a;
      border-color: #c6d7e8;
    }
    .inp:focus, .sel:focus, .txt:focus {
      outline: none;
      border-color: #75a8d5;
      box-shadow: 0 0 0 3px rgba(62, 133, 196, 0.14);
    }
    .txt { min-height: 90px; resize: vertical; }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 5px; }
    .msg { display: none; padding: 9px 10px; border-radius: 9px; border: 1px solid transparent; font-size: 13px; }
    .msg.show { display: block; }
    .msg.error { background: #ffeaea; border-color: #edb8b8; color: var(--danger); }
    .msg.ok { background: #ebfaf1; border-color: #b7dfc8; color: var(--ok); }
    .msg.info { background: #eaf4ff; border-color: #bad6f6; color: #23527d; }
    .empty {
      border: 1px dashed #c8d6e7;
      border-radius: 10px;
      padding: 10px;
      font-size: 13px;
      color: var(--muted);
      background: linear-gradient(180deg, #fbfdff 0%, #f4f9ff 100%);
    }
    .timer { font-size: 30px; font-weight: 700; font-variant-numeric: tabular-nums; margin: 0 0 4px 0; }
    .tbl-wrap {
      border: 1px solid var(--line);
      border-radius: 10px;
      overflow-y: auto;
      overflow-x: hidden;
      max-height: 360px;
      background: #fff;
    }
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      min-width: 0;
      table-layout: fixed;
      font-size: 12px;
    }
    th, td {
      border-bottom: 1px solid #e8eff7;
      padding: 8px;
      text-align: left;
      vertical-align: top;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    th {
      position: sticky;
      top: 0;
      z-index: 1;
      background: #f3f8ff;
    }
    .comments { display: grid; gap: 8px; max-height: 360px; overflow: auto; }
    .comment { border: 1px solid var(--line); border-radius: 9px; padding: 8px; background: #fff; }
    .comment.mine { background: #f7fbff; border: 2px solid #2f8bcb; }
    .meta { display: flex; justify-content: space-between; gap: 8px; color: var(--muted); font-size: 11px; margin-bottom: 4px; flex-wrap: wrap; }
    .body { white-space: pre-wrap; font-size: 13px; overflow-wrap: anywhere; }
    .track { height: 10px; border-radius: 999px; background: #edf3f9; position: relative; overflow: hidden; }
    .bar { position: absolute; top: 0; bottom: 0; border-radius: 999px; background: linear-gradient(90deg, #1d74c7, #4ab2dc); }
    .timeline-item { border: 1px solid var(--line); border-radius: 9px; padding: 7px; margin-bottom: 8px; }
    .timeline-axis {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      color: var(--muted);
      font-size: 11px;
    }
    .timeline-ticket-list {
      display: grid;
      gap: 8px;
    }
    .timeline-ticket-row {
      display: grid;
      grid-template-columns: 180px 1fr 70px;
      gap: 8px;
      align-items: center;
    }
    .timeline-ticket-label {
      font-size: 12px;
      color: var(--text);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .timeline-ticket-track {
      position: relative;
      height: 16px;
      border: 1px solid #dce7f2;
      border-radius: 999px;
      background: linear-gradient(180deg, #f4f8fc 0%, #edf3fa 100%);
      overflow: hidden;
    }
    .timeline-ticket-segment {
      position: absolute;
      top: 2px;
      bottom: 2px;
      border-radius: 999px;
      min-width: 2px;
      opacity: 0.92;
    }
    .timeline-ticket-total {
      font-size: 11px;
      color: var(--muted);
      text-align: right;
      white-space: nowrap;
    }
    .activity-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
    }
    .activity-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #d7e3f1;
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 11px;
      color: #334f68;
      background: #f8fbff;
      max-width: 100%;
    }
    .activity-legend-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      flex: 0 0 auto;
    }
    .gantt-row { display: grid; grid-template-columns: 190px 1fr 60px; gap: 7px; align-items: center; margin-bottom: 7px; font-size: 12px; }
    .recent-line {
      font-size: 12px;
      flex: 1;
      min-width: 0;
      white-space: normal;
      overflow-wrap: anywhere;
    }
    #userPill { max-width: 360px; }
    #debugLogBox {
      margin: 8px 0 0 0;
      max-height: 180px;
      overflow: auto;
      background: #f6f9fd;
      border: 1px solid #d6e3f0;
      border-radius: 10px;
      padding: 10px;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .float {
      position: fixed; right: 12px; bottom: 12px; width: 255px;
      border: 1px solid #b4cae3; border-radius: 11px; padding: 9px;
      background: #eff6ff; display: none; z-index: 9998;
      box-shadow: var(--shadow);
    }
    .float.show { display: block; }
    .modal {
      position: fixed; inset: 0; background: rgba(15, 23, 38, .45);
      display: none; align-items: center; justify-content: center; padding: 12px; z-index: 9999;
    }
    .modal.show { display: flex; }
    .modal-card {
      width: min(560px, 100%);
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      max-height: calc(100vh - 36px);
      overflow: auto;
    }
    .hide { display: none !important; }
    #timerCard,
    #compactBtn,
    #floatBox {
      display: none !important;
    }
    details.debug-panel {
      padding: 0;
    }
    details.debug-panel summary {
      list-style: none;
      cursor: pointer;
      padding: 12px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      user-select: none;
    }
    details.debug-panel summary::-webkit-details-marker {
      display: none;
    }
    details.debug-panel summary::after {
      content: 'Mostrar';
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 3px 8px;
      background: #fff;
    }
    details.debug-panel[open] summary {
      border-bottom: 1px solid #e5eef8;
    }
    details.debug-panel[open] summary::after {
      content: 'Ocultar';
    }
    .debug-body {
      padding: 12px 14px 14px;
    }
    @media (max-width: 1180px) {
      body { padding: 12px; }
    }
    @media (max-width: 700px) {
      .grid2, .grid3 { grid-template-columns: 1fr; }
      .activity-config-grid { grid-template-columns: 1fr; }
      .dashboard-grid { grid-template-columns: 1fr; }
      .panel-timeline,
      .panel-suggestion,
      .panel-comments,
      .panel-worklogs {
        grid-column: auto;
        grid-row: auto;
      }
      .gantt-row { grid-template-columns: 1fr; }
      .timeline-ticket-row { grid-template-columns: 1fr; }
      .timeline-ticket-total { text-align: left; }
      .float { left: 10px; right: 10px; width: auto; }
      .topbar { gap: 10px; }
      #userPill { max-width: 100%; }
    }
    @media (max-width: 640px) {
      body { padding: 8px; }
      .card { padding: 11px; border-radius: 12px; }
      .timer { font-size: 26px; }
      .btn { width: 100%; justify-content: center; }
      .row > .btn { flex: 1 1 100%; }
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="card row topbar">
      <div>
        <h2>Jira Focus Web</h2>
        <div class="muted">Trabajo en Jira Cloud, frontend puro, persistencia local.</div>
      </div>
      <div class="row" style="margin-left:auto;">
        <span class="pill" id="connPill">Sin conexion</span>
        <span class="pill" id="userPill">Usuario: -</span>
        <button class="btn" id="refreshIssuesBtn" type="button" disabled>Recargar tickets</button>
        <button class="btn danger" id="disconnectBtn" type="button" disabled>Desconectar</button>
      </div>
    </div>

    <div class="msg" id="msg"></div>
    <div class="msg" id="idleMsg"></div>
    <details class="card debug-panel">
      <summary>Logs de depuracion (tecnico)</summary>
      <div class="debug-body">
        <div class="row" style="justify-content:space-between;">
          <div class="muted">No se registran tokens, codes ni secrets. Solo eventos tecnicos.</div>
          <div class="row">
            <button class="btn" id="debugCopyBtn" type="button">Copiar logs</button>
            <button class="btn" id="debugClearBtn" type="button">Limpiar logs</button>
          </div>
        </div>
        <pre id="debugLogBox"></pre>
      </div>
    </details>

    <section class="card" id="loginView">
      <h3>Conectar Jira Cloud</h3>
      <div class="muted">OAuth 2.0 PKCE. Configuracion local en <code>jira_config</code> (sin exponer tokens en UI).</div>
      <div class="grid3" style="margin-top:8px;">
        <div>
          <label for="urlInp">URL Jira</label>
          <input class="inp" id="urlInp" type="url" placeholder="https://tu-dominio.atlassian.net" autocomplete="off">
        </div>
        <div>
          <label for="clientIdInp">Atlassian OAuth Client ID</label>
          <input class="inp" id="clientIdInp" type="text" placeholder="Tu client id 3LO" autocomplete="off">
        </div>
        <div>
          <label for="clientSecretInp">Atlassian OAuth Client Secret</label>
          <input class="inp" id="clientSecretInp" type="password" placeholder="Tu client secret 3LO" autocomplete="new-password">
        </div>
      </div>
      <div class="grid3" style="margin-top:8px;">
        <div>
          <label for="redirectUriInp">Redirect URI</label>
          <input class="inp" id="redirectUriInp" type="url" placeholder="https://tu-app/">
        </div>
      </div>
      <div class="muted" style="margin-top:8px;">
        Registra este Redirect URI en tu app OAuth de Atlassian. Si no se detecta callback automatico, pega la URL retornada:
      </div>
      <div class="grid2" style="margin-top:8px;">
        <div>
          <label for="callbackUrlInp">URL de callback (manual)</label>
          <input class="inp" id="callbackUrlInp" type="text" placeholder="https://tu-app/?code=...&state=...">
        </div>
        <div class="row" style="align-items:flex-end;">
          <button class="btn" id="processCallbackBtn" type="button">Procesar callback</button>
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="connectBtn" type="button">Conectar con OAuth</button>
        <button class="btn danger" id="clearOAuthBtn" type="button">Limpiar sesion OAuth local</button>
      </div>
    </section>

    <section id="mainView" class="hide">
      <div class="card board-head">
        <div class="board-ticket-picker">
          <label for="issueSel">Ticket actual</label>
          <select class="sel" id="issueSel"></select>
        </div>
      </div>

      <div class="hide" aria-hidden="true">
        <button class="btn" id="compactBtn" type="button">Modo compacto</button>
        <div class="activity-config-grid">
          <div>
            <label for="activityTypeSel">Tipo de actividad (oficial)</label>
            <select class="sel" id="activityTypeSel"></select>
          </div>
          <div>
            <label for="activityDueInp">Fecha fin (actividad)</label>
            <input class="inp" id="activityDueInp" type="date">
          </div>
          <div>
            <label for="minutesInp">Duracion (min)</label>
            <input class="inp" id="minutesInp" type="number" min="1" step="1" value="30">
          </div>
          <div class="row" style="margin-top:22px;">
            <button class="btn primary" id="registerBtn" type="button">Registrar worklog</button>
            <span class="pill" id="jiraDurationPill">0m</span>
          </div>
        </div>
        <div style="margin-top:8px;">
          <label for="activityInp">Actividad final</label>
          <input class="inp" id="activityInp" type="text" readonly>
          <datalist id="activityList"></datalist>
        </div>
        <div id="timerCard" class="card">
          <h3>Cronometro laboral</h3>
          <p class="timer" id="timerVal">00:00:00</p>
          <div class="muted" id="timerState">Estado: inactivo</div>
          <div class="muted" style="margin-top:4px;">Horario habil: L-V 08:30 a 18:00.</div>
          <div class="row" style="margin-top:10px;">
            <button class="btn" id="startBtn" type="button">Iniciar</button>
            <button class="btn warn" id="pauseBtn" type="button">Pausar</button>
            <button class="btn" id="resetBtn" type="button">Reiniciar</button>
            <button class="btn" id="applyTimerBtn" type="button">Usar tiempo</button>
          </div>
        </div>
      </div>

      <div class="dashboard-grid">
        <div class="card panel-timeline">
          <h3>Linea de tiempo / Gantt</h3>
          <div id="timelineBox" class="empty">Sin registros.</div>
          <h4 style="margin-top:10px;">Gantt por actividad</h4>
          <div id="ganttBox" class="empty">Sin registros.</div>
        </div>
        <div class="card panel-suggestion">
          <h3>Sugerencia automatica</h3>
          <div id="suggestionBox" class="empty">Selecciona un ticket para buscar sugerencias.</div>
          <div class="row" style="margin-top:10px;">
            <button class="btn" id="applySugActBtn" type="button" disabled>Aplicar actividad</button>
            <button class="btn" id="applySugTimeBtn" type="button" disabled>Aplicar tiempo</button>
            <button class="btn primary" id="registerSugBtn" type="button" disabled>Registrar sugerencia</button>
          </div>
        </div>
        <div class="card panel-comments">
          <h3>Comentarios del ticket</h3>
          <div id="commentsBox" class="comments"></div>
        </div>
        <div class="card panel-worklogs">
          <h3>Historial editable por ticket</h3>
          <div class="tbl-wrap">
            <table>
              <thead><tr><th>Fecha</th><th>Actividad</th><th>Duracion</th><th>Autor</th><th>Acciones</th></tr></thead>
              <tbody id="worklogBody"></tbody>
            </table>
          </div>
        </div>
      </div>

      <div id="dashboardCard" class="card hide" style="margin-top:10px;">
        <h3>Dashboard global</h3>
        <div class="grid3">
          <div class="card" style="padding:8px;">
            <div class="muted">Total hoy</div>
            <div id="todayTotal" style="font-weight:700;font-size:18px;">0m</div>
          </div>
          <div class="card" style="padding:8px;">
            <div class="muted">Total semana</div>
            <div id="weekTotal" style="font-weight:700;font-size:18px;">0m</div>
          </div>
          <div class="card" style="padding:8px;">
            <div class="muted">Tickets con registros</div>
            <div id="issueCount" style="font-weight:700;font-size:18px;">0</div>
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <button class="btn" id="refreshDashBtn" type="button">Actualizar dashboard</button>
          <span class="muted" id="dashMeta">Sin datos.</span>
        </div>
        <div id="recentBox" class="empty" style="margin-top:8px;">Sin historial reciente.</div>
      </div>

      <div id="reportCard" class="card hide" style="margin-top:10px;">
        <h3>Reporte plantilla + .xlsx</h3>
        <div class="muted">Detecta comentarios con "plantilla" y adjuntos/links .xlsx. Agrupa por colegio segun resumen normalizado.</div>
        <div class="row" style="margin-top:10px;">
          <button class="btn primary" id="genReportBtn" type="button">Generar reporte</button>
          <button class="btn" id="exportReportBtn" type="button" disabled>Exportar Excel</button>
        </div>
        <div class="muted" id="reportMeta" style="margin-top:8px;">Sin reporte.</div>
        <div class="tbl-wrap" style="margin-top:8px;">
          <table>
            <thead><tr><th>Colegio</th><th>Tickets</th><th>Comentarios</th><th>Adjuntos .xlsx</th></tr></thead>
            <tbody id="reportBody"></tbody>
          </table>
        </div>
      </div>
    </section>
  </div>

  <div class="float" id="floatBox">
    <div class="muted" id="floatIssue">-</div>
    <div style="font-size:26px;font-weight:700;font-variant-numeric:tabular-nums;" id="floatTimer">00:00:00</div>
    <div class="muted" id="floatState">Estado: inactivo</div>
    <div class="row" style="margin-top:8px;">
      <button class="btn" id="floatStartBtn" type="button">Iniciar</button>
      <button class="btn warn" id="floatPauseBtn" type="button">Pausar</button>
      <button class="btn" id="floatExpandBtn" type="button">Expandir</button>
    </div>
  </div>

  <div class="modal" id="regModal">
    <div class="modal-card">
      <h3>Registrar actividad</h3>
      <div class="muted" id="regModalMeta"></div>
      <div class="grid2" style="margin-top:8px;">
        <div><label for="regActInp">Actividad</label><input id="regActInp" class="inp" type="text"></div>
        <div><label for="regMinInp">Duracion (min)</label><input id="regMinInp" class="inp" type="number" min="1" step="1"></div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="regModalOkBtn" type="button">Registrar</button>
        <button class="btn" id="regModalCancelBtn" type="button">Cancelar</button>
      </div>
    </div>
  </div>

  <div class="modal" id="editModal">
    <div class="modal-card">
      <h3>Editar worklog</h3>
      <div class="muted" id="editMeta"></div>
      <div class="grid3" style="margin-top:8px;">
        <div><label for="editActInp">Actividad</label><input id="editActInp" class="inp" type="text"></div>
        <div><label for="editDateInp">Fecha</label><input id="editDateInp" class="inp" type="date"></div>
        <div><label for="editTimeInp">Hora</label><input id="editTimeInp" class="inp" type="time" step="60"></div>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <div><label for="editMinInp">Duracion (min)</label><input id="editMinInp" class="inp" type="number" min="1" step="1"></div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="editSaveBtn" type="button">Guardar</button>
        <button class="btn danger" id="editDeleteBtn" type="button">Eliminar</button>
        <button class="btn" id="editCancelBtn" type="button">Cancelar</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    (() => {
      'use strict';

      const STORAGE = {
        config: 'jira_config',
        oauthTokens: 'jira_oauth_tokens',
        oauthPending: 'jira_oauth_pending',
        oauthDone: 'jira_oauth_done',
        timer: 'jira_focus_timer_state',
        ui: 'jira_focus_ui_state',
        lastActivity: 'jira_focus_last_activity',
        activities: 'jira_focus_activities'
      };
      const OAUTH = {
        authorizeUrl: 'https://auth.atlassian.com/authorize',
        tokenUrl: 'https://auth.atlassian.com/oauth/token',
        resourcesUrl: 'https://api.atlassian.com/oauth/token/accessible-resources',
        scopes: [
          'read:jira-user',
          'read:jira-work',
          'write:jira-work',
          'delete:jira-work',
          'offline_access'
        ]
      };
      const DEBUG_MAX = 140;
      const LABOR = { startHour: 8, startMinute: 30, endHour: 18, endMinute: 0, dayMinutes: 570, weekMinutes: 2850 };
      const INACTIVITY_MS = 2 * 60 * 60 * 1000;
      const SUGGESTION_MS = 3 * 24 * 60 * 60 * 1000;
      const OFFICIAL_ACTIVITY_TYPES = [
        'Configuración Agente de Éxito',
        'Estandarización de plantillas',
        'Entrega de plantillas DOCENTES Coach/Farmer/Hunter',
        'Entrega de plantillas ESTUDIANTES Coach/Farmer/Hunter',
        'Pendiente información',
        'Integración LQL',
        'Integración RLP',
        'Integración LDB',
        'Integración WeMath',
        'Integración Pleno',
        'Configuración de colegio',
        'Configuración de docentes',
        'Configuración de estudiantes',
        'Integración Studio'
      ];
      const ACTIVITY_PALETTE = [
        '#1b78c4', '#1f8f71', '#e07a2f', '#7a57c2', '#c63f69', '#3e8f5b', '#2e7fba',
        '#aa5d13', '#5f7bca', '#0f8fa8', '#b0453e', '#1d9164', '#8568c8', '#ad4c88'
      ];
      const FEATURES = {
        dashboard: false,
        report: false
      };

      const state = {
        connected: false,
        config: null,
        me: null,
        issues: [],
        selectedIssueKey: '',
        activity: '',
        activityType: OFFICIAL_ACTIVITY_TYPES[0],
        activityDueDate: '',
        durationMinutes: 30,
        commentsByIssue: {},
        worklogsByIssue: {},
        suggestion: null,
        compact: false,
        report: { detail: [], grouped: [] },
        dash: { logs: [], today: 0, week: 0, issueCount: 0, refreshedAt: null },
        timer: { running: false, resumeTs: 0, elapsedBizMs: 0 },
        oauthTokens: null,
        lastActivityTs: Date.now(),
        lastReminderTs: 0,
        regCtx: null,
        editCtx: null,
        activities: [],
        debugLogs: [],
        popupWatchTimer: 0,
        popupProcessing: false,
        oauthCallbackInProgress: false
      };

      const el = {};
      const StorageService = {
        parse(raw, fb) { try { return raw ? JSON.parse(raw) : fb; } catch (_e) { return fb; } },
        get(key) { try { return localStorage.getItem(key); } catch (_e) { return null; } },
        set(key, val) { try { localStorage.setItem(key, val); } catch (_e) {} },
        del(key) { try { localStorage.removeItem(key); } catch (_e) {} },
        getConfig() {
          const cfg = this.parse(this.get(STORAGE.config), null);
          if (!cfg || typeof cfg !== 'object') return null;
          const url = sanitizeUrl(cfg.url || '');
          const client_id = String(cfg.client_id || '').trim();
          const client_secret = String(cfg.client_secret || '');
          const redirect_uri = String(cfg.redirect_uri || '').trim();
          const cloud_id = String(cfg.cloud_id || '').trim();
          if (!url || !client_id || !client_secret || !redirect_uri) return null;
          return {
            url,
            client_id,
            client_secret,
            redirect_uri,
            cloud_id,
            // keep compatibility fields expected by old config shape
            email: String(cfg.email || '').trim(),
            api_token: String(cfg.api_token || '')
          };
        },
        saveConfig(cfg) {
          this.set(STORAGE.config, JSON.stringify({
            url: sanitizeUrl(cfg.url || ''),
            email: '',
            api_token: '',
            client_id: String(cfg.client_id || '').trim(),
            client_secret: String(cfg.client_secret || ''),
            redirect_uri: String(cfg.redirect_uri || '').trim(),
            cloud_id: String(cfg.cloud_id || '').trim()
          }));
        },
        getOAuthTokens() {
          const tokenData = this.parse(this.get(STORAGE.oauthTokens), null);
          if (!tokenData || typeof tokenData !== 'object') return null;
          const access_token = String(tokenData.access_token || '');
          const refresh_token = String(tokenData.refresh_token || '');
          const expires_at = Number(tokenData.expires_at || 0);
          if (!access_token || !expires_at) return null;
          return { access_token, refresh_token, expires_at };
        },
        saveOAuthTokens(tokens) {
          this.set(STORAGE.oauthTokens, JSON.stringify({
            access_token: String(tokens.access_token || ''),
            refresh_token: String(tokens.refresh_token || ''),
            expires_at: Number(tokens.expires_at || 0)
          }));
        },
        clearOAuthTokens() {
          this.del(STORAGE.oauthTokens);
        },
        getOAuthPending() {
          const pending = this.parse(this.get(STORAGE.oauthPending), null);
          if (!pending || typeof pending !== 'object') return null;
          const state = String(pending.state || '');
          const code_verifier = String(pending.code_verifier || '');
          const created_at = Number(pending.created_at || 0);
          if (!state || !code_verifier || !created_at) return null;
          return pending;
        },
        saveOAuthPending(payload) {
          this.set(STORAGE.oauthPending, JSON.stringify(payload || {}));
        },
        clearOAuthPending() {
          this.del(STORAGE.oauthPending);
        },
        markOAuthDone(source) {
          this.set(STORAGE.oauthDone, JSON.stringify({
            at: Date.now(),
            source: String(source || '')
          }));
        },
        clearOAuthDone() {
          this.del(STORAGE.oauthDone);
        },
        getTimer() {
          const t = this.parse(this.get(STORAGE.timer), null);
          if (!t) return null;
          return { running: !!t.running, resumeTs: Number(t.resumeTs || 0), elapsedBizMs: Number(t.elapsedBizMs || 0) };
        },
        saveTimer(t) {
          this.set(STORAGE.timer, JSON.stringify({ running: !!t.running, resumeTs: Number(t.resumeTs || 0), elapsedBizMs: Number(t.elapsedBizMs || 0) }));
        },
        getUI() { return this.parse(this.get(STORAGE.ui), {}) || {}; },
        saveUI(v) { this.set(STORAGE.ui, JSON.stringify(v || {})); },
        getLastActivity() {
          const ts = Number(this.get(STORAGE.lastActivity));
          return Number.isFinite(ts) && ts > 0 ? ts : Date.now();
        },
        saveLastActivity(ts) { this.set(STORAGE.lastActivity, String(Number(ts || Date.now()))); },
        getActivities() {
          const list = this.parse(this.get(STORAGE.activities), []);
          return Array.isArray(list) ? list.filter((x) => typeof x === 'string' && x.trim()).slice(0, 100) : [];
        },
        saveActivities(list) {
          this.set(STORAGE.activities, JSON.stringify((list || []).slice(0, 100)));
        }
      };

      const TimeService = {
        isWeekday(d) { const day = d.getDay(); return day >= 1 && day <= 5; },
        dayWindow(d) {
          if (!this.isWeekday(d)) return null;
          const start = new Date(d); start.setHours(LABOR.startHour, LABOR.startMinute, 0, 0);
          const end = new Date(d); end.setHours(LABOR.endHour, LABOR.endMinute, 0, 0);
          return { start, end };
        },
        isBusinessNow(d) {
          const w = this.dayWindow(d);
          return !!w && d >= w.start && d <= w.end;
        },
        businessMsBetween(a, b) {
          const start = new Date(a); const end = new Date(b);
          if (!(start < end)) return 0;
          let total = 0;
          let cur = new Date(start);
          while (cur < end) {
            const w = this.dayWindow(cur);
            if (w) {
              const s = Math.max(cur.getTime(), w.start.getTime());
              const e = Math.min(end.getTime(), w.end.getTime());
              if (e > s) total += (e - s);
            }
            cur.setHours(24, 0, 0, 0);
          }
          return total;
        },
        businessMinutesBetween(a, b) { return Math.floor(this.businessMsBetween(a, b) / 60000); },
        prevBusinessEnd(dateIn) {
          const d = new Date(dateIn);
          while (true) {
            d.setDate(d.getDate() - 1);
            const w = this.dayWindow(d);
            if (w) return new Date(w.end);
          }
        },
        subtractBusinessMinutes(endIn, minsIn) {
          let remain = Math.max(0, Math.floor(Number(minsIn || 0)));
          let cur = new Date(endIn);
          if (!remain) return cur;
          while (remain > 0) {
            const w = this.dayWindow(cur);
            if (!w) { cur = this.prevBusinessEnd(cur); continue; }
            if (cur > w.end) cur = new Date(w.end);
            if (cur <= w.start) { cur = this.prevBusinessEnd(cur); continue; }
            const available = Math.floor((cur.getTime() - w.start.getTime()) / 60000);
            if (available >= remain) {
              cur = new Date(cur.getTime() - remain * 60000);
              remain = 0;
            } else {
              remain -= available;
              cur = this.prevBusinessEnd(cur);
            }
          }
          return cur;
        },
        hhmmss(msIn) {
          const total = Math.floor(Math.max(0, Number(msIn || 0)) / 1000);
          const h = Math.floor(total / 3600);
          const m = Math.floor((total % 3600) / 60);
          const s = total % 60;
          return [h, m, s].map((x) => String(x).padStart(2, '0')).join(':');
        },
        ddmmyyyy(dIn) {
          const d = new Date(dIn);
          const dd = String(d.getDate()).padStart(2, '0');
          const mm = String(d.getMonth() + 1).padStart(2, '0');
          return `${dd}/${mm}/${d.getFullYear()}`;
        },
        dtLabel(dIn) {
          const d = new Date(dIn);
          const hh = String(d.getHours()).padStart(2, '0');
          const mi = String(d.getMinutes()).padStart(2, '0');
          return `${this.ddmmyyyy(d)} ${hh}:${mi}`;
        },
        jiraDateTime(dIn) {
          const d = new Date(dIn);
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          const hh = String(d.getHours()).padStart(2, '0');
          const mi = String(d.getMinutes()).padStart(2, '0');
          const ss = String(d.getSeconds()).padStart(2, '0');
          const off = -d.getTimezoneOffset();
          const sign = off >= 0 ? '+' : '-';
          const abs = Math.abs(off);
          const oh = String(Math.floor(abs / 60)).padStart(2, '0');
          const om = String(abs % 60).padStart(2, '0');
          return `${y}-${m}-${day}T${hh}:${mi}:${ss}.000${sign}${oh}${om}`;
        },
        jiraDuration(minsIn) {
          let mins = Math.max(0, Math.floor(Number(minsIn || 0)));
          const parts = [];
          const w = Math.floor(mins / LABOR.weekMinutes); mins -= w * LABOR.weekMinutes;
          const d = Math.floor(mins / LABOR.dayMinutes); mins -= d * LABOR.dayMinutes;
          const h = Math.floor(mins / 60); mins -= h * 60;
          if (w) parts.push(`${w}w`);
          if (d) parts.push(`${d}d`);
          if (h) parts.push(`${h}h`);
          if (mins || !parts.length) parts.push(`${mins}m`);
          return parts.join(' ');
        },
        startOfToday() { const d = new Date(); d.setHours(0, 0, 0, 0); return d; },
        startOfWeek() {
          const d = new Date();
          const day = d.getDay();
          const diff = day === 0 ? -6 : 1 - day;
          d.setDate(d.getDate() + diff);
          d.setHours(0, 0, 0, 0);
          return d;
        },
        toInputDate(dIn) {
          const d = new Date(dIn);
          return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
        },
        toInputTime(dIn) {
          const d = new Date(dIn);
          return `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
        }
      };

      function isValidInputDate(value) {
        const text = String(value || '').trim();
        if (!/^\d{4}-\d{2}-\d{2}$/.test(text)) return false;
        const d = new Date(`${text}T00:00:00`);
        return !Number.isNaN(d.getTime()) && TimeService.toInputDate(d) === text;
      }

      function inputDateToDdmmyyyy(value) {
        const text = String(value || '').trim();
        if (!isValidInputDate(text)) return '';
        const [y, m, d] = text.split('-');
        return `${d}/${m}/${y}`;
      }

      function ddmmyyyyToInputDate(value) {
        const text = String(value || '').trim();
        const m = text.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
        if (!m) return '';
        const input = `${m[3]}-${m[2]}-${m[1]}`;
        return isValidInputDate(input) ? input : '';
      }

      function buildOfficialActivity(typeName, dueInputDate) {
        const type = OFFICIAL_ACTIVITY_TYPES.includes(String(typeName || '').trim())
          ? String(typeName || '').trim()
          : OFFICIAL_ACTIVITY_TYPES[0];
        const due = isValidInputDate(dueInputDate) ? dueInputDate : TimeService.toInputDate(new Date());
        const dueDdmmyyyy = inputDateToDdmmyyyy(due);
        return `[${type}] [${dueDdmmyyyy}]`;
      }

      function parseOfficialActivity(text) {
        const raw = String(text || '').trim();
        const match = raw.match(/^\[(.+?)\]\s+\[(\d{2}\/\d{2}\/\d{4})\]$/);
        if (!match) return null;
        const type = String(match[1] || '').trim();
        const dueDdmmyyyy = String(match[2] || '').trim();
        const dueInput = ddmmyyyyToInputDate(dueDdmmyyyy);
        if (!dueInput || !OFFICIAL_ACTIVITY_TYPES.includes(type)) {
          return null;
        }
        return { type, dueInput };
      }

      function worklogCommentFromActivity(activityValue, refDate) {
        const act = String(activityValue || '').trim();
        if (!act) return '';
        if (parseOfficialActivity(act)) {
          return act;
        }
        const fallbackDate = TimeService.ddmmyyyy(refDate || new Date());
        return `[${act}] [${fallbackDate}]`;
      }

      function hashText(input) {
        const text = String(input || '');
        let hash = 0;
        for (let i = 0; i < text.length; i += 1) {
          hash = ((hash << 5) - hash + text.charCodeAt(i)) | 0;
        }
        return Math.abs(hash);
      }

      function activityColor(activityName) {
        const act = String(activityName || '').trim();
        if (!act) return ACTIVITY_PALETTE[0];
        const officialIndex = OFFICIAL_ACTIVITY_TYPES.findIndex((name) => name.toLowerCase() === act.toLowerCase());
        const idx = officialIndex >= 0 ? officialIndex : (hashText(act) % ACTIVITY_PALETTE.length);
        return ACTIVITY_PALETTE[idx % ACTIVITY_PALETTE.length];
      }

      const OAuthService = {
        async sha256Base64Url(input) {
          const data = new TextEncoder().encode(String(input || ''));
          const digest = await crypto.subtle.digest('SHA-256', data);
          return base64UrlEncode(new Uint8Array(digest));
        },
        randomString(size) {
          const bytes = new Uint8Array(size);
          crypto.getRandomValues(bytes);
          return base64UrlEncode(bytes).slice(0, size * 2);
        },
        async startAuth(cfg, popupWindow) {
          dbg('oauth_start', {
            jira_host: safeHostname(cfg.url),
            redirect_host: safeHostname(cfg.redirect_uri),
            has_client_secret: !!cfg.client_secret,
            has_popup: !!popupWindow
          });
          const codeVerifier = this.randomString(64);
          const codeChallenge = await this.sha256Base64Url(codeVerifier);
          const oauthState = this.randomString(32);
          StorageService.saveOAuthPending({
            state: oauthState,
            code_verifier: codeVerifier,
            created_at: Date.now(),
            redirect_uri: cfg.redirect_uri,
            url: cfg.url,
            client_id: cfg.client_id
          });
          const authUrl = new URL(OAUTH.authorizeUrl);
          authUrl.searchParams.set('audience', 'api.atlassian.com');
          authUrl.searchParams.set('client_id', cfg.client_id);
          authUrl.searchParams.set('scope', OAUTH.scopes.join(' '));
          authUrl.searchParams.set('redirect_uri', cfg.redirect_uri);
          authUrl.searchParams.set('state', oauthState);
          authUrl.searchParams.set('response_type', 'code');
          authUrl.searchParams.set('prompt', 'consent');
          authUrl.searchParams.set('code_challenge', codeChallenge);
          authUrl.searchParams.set('code_challenge_method', 'S256');
          navigateTop(authUrl.toString(), popupWindow);
        },
        async tokenRequest(payload) {
          dbg('oauth_token_request', { grant_type: payload && payload.grant_type ? payload.grant_type : '' });
          let res;
          try {
            res = await fetch(OAUTH.tokenUrl, {
              method: 'POST',
              headers: { Accept: 'application/json', 'Content-Type': 'application/json' },
              body: JSON.stringify(payload || {})
            });
          } catch (_e) {
            const err = new Error('No se pudo llegar a auth.atlassian.com (posible bloqueo de red/CORS).');
            err.kind = 'cors';
            throw err;
          }
          const raw = await res.text();
          let data = null;
          if (raw) {
            try { data = JSON.parse(raw); } catch (_e) { data = null; }
          }
          dbg('oauth_token_response', { status: res.status, ok: res.ok });
          if (!res.ok) {
            dbg('oauth_token_error_payload', data && typeof data === 'object' ? data : { raw: raw ? raw.slice(0, 200) : '' });
            const err = new Error(httpMessage(data, res.status));
            err.kind = 'oauth';
            err.status = res.status;
            throw err;
          }
          return data || {};
        },
        async exchangeCode(cfg, code, codeVerifier) {
          const data = await this.tokenRequest({
            grant_type: 'authorization_code',
            client_id: cfg.client_id,
            client_secret: cfg.client_secret,
            code: String(code || ''),
            redirect_uri: cfg.redirect_uri,
            code_verifier: codeVerifier
          });
          return this.normalizeTokenPayload(data);
        },
        async refresh(cfg, refreshToken) {
          const data = await this.tokenRequest({
            grant_type: 'refresh_token',
            client_id: cfg.client_id,
            client_secret: cfg.client_secret,
            refresh_token: String(refreshToken || '')
          });
          return this.normalizeTokenPayload(data, refreshToken);
        },
        normalizeTokenPayload(data, fallbackRefreshToken) {
          const accessToken = String(data.access_token || '');
          const refreshToken = String(data.refresh_token || fallbackRefreshToken || '');
          const expiresIn = Number(data.expires_in || 0);
          if (!accessToken || !expiresIn) {
            const err = new Error('Respuesta OAuth incompleta.');
            err.kind = 'oauth';
            throw err;
          }
          return {
            access_token: accessToken,
            refresh_token: refreshToken,
            expires_at: Date.now() + Math.max(60, expiresIn - 45) * 1000
          };
        },
        async ensureValidTokens(cfg) {
          const current = StorageService.getOAuthTokens();
          if (!current) {
            const err = new Error('No existe sesion OAuth en localStorage.');
            err.kind = 'oauth';
            err.status = 401;
            throw err;
          }
          const stillValid = current.expires_at > Date.now() + 15000;
          if (stillValid) {
            state.oauthTokens = current;
            return current;
          }
          if (!current.refresh_token) {
            StorageService.clearOAuthTokens();
            const err = new Error('Sesion expirada. Reconecta OAuth.');
            err.kind = 'oauth';
            err.status = 401;
            throw err;
          }
          const refreshed = await this.refresh(cfg, current.refresh_token);
          StorageService.saveOAuthTokens(refreshed);
          state.oauthTokens = refreshed;
          return refreshed;
        },
        async getResources(accessToken) {
          let res;
          try {
            res = await fetch(OAUTH.resourcesUrl, {
              method: 'GET',
              headers: {
                Accept: 'application/json',
                Authorization: `Bearer ${accessToken}`
              }
            });
          } catch (_e) {
            const err = new Error('No se pudo consultar accessible-resources (CORS/red).');
            err.kind = 'cors';
            throw err;
          }
          const raw = await res.text();
          let data = null;
          if (raw) {
            try { data = JSON.parse(raw); } catch (_e) { data = null; }
          }
          if (!res.ok) {
            const err = new Error(httpMessage(data, res.status));
            err.kind = 'oauth';
            err.status = res.status;
            throw err;
          }
          return Array.isArray(data) ? data : [];
        },
        pickCloudResource(resources, jiraUrl) {
          const site = sanitizeUrl(jiraUrl);
          const siteHost = safeHostname(site);
          let match = resources.find((r) => sanitizeUrl(r.url || '') === site);
          if (!match && siteHost) {
            match = resources.find((r) => safeHostname(r.url || '') === siteHost);
          }
          if (!match && resources.length === 1) {
            match = resources[0];
          }
          if (!match) {
            const err = new Error('No se encontro recurso accesible para la URL Jira indicada.');
            err.kind = 'oauth';
            err.status = 404;
            throw err;
          }
          return match;
        }
      };

      const JiraService = {
        cloudId: '',
        setCloudId(cloudId) {
          this.cloudId = String(cloudId || '').trim();
        },
        url(path, params) {
          if (!this.cloudId) {
            throw new Error('cloudId no configurado.');
          }
          const base = `https://api.atlassian.com/ex/jira/${encodeURIComponent(this.cloudId)}`;
          const u = new URL(base + path);
          Object.entries(params || {}).forEach(([k, v]) => {
            if (v === undefined || v === null || v === '') return;
            u.searchParams.append(k, String(v));
          });
          return u.toString();
        },
        async req(method, path, opts = {}, retried = false) {
          const cfg = StorageService.getConfig();
          if (!cfg) {
            const err = new Error('No existe configuracion OAuth.');
            err.kind = 'oauth';
            err.status = 401;
            throw err;
          }
          const tokens = await OAuthService.ensureValidTokens(cfg);
          const init = {
            method,
            headers: {
              Accept: 'application/json',
              'Content-Type': 'application/json',
              Authorization: `Bearer ${tokens.access_token}`
            }
          };
          if (opts.body !== undefined) init.body = JSON.stringify(opts.body);
          let res;
          try {
            res = await fetch(this.url(path, opts.params || {}), init);
          } catch (_e) {
            const err = new Error('No se pudo conectar directo a Jira Cloud (posible CORS/red).');
            err.kind = 'cors';
            throw err;
          }
          const raw = await res.text();
          let payload = null;
          if (raw) { try { payload = JSON.parse(raw); } catch (_e) { payload = null; } }
          if (!res.ok) {
            if (res.status === 401 && !retried) {
              try {
                await OAuthService.refresh(cfg, tokens.refresh_token).then((newTokens) => {
                  StorageService.saveOAuthTokens(newTokens);
                  state.oauthTokens = newTokens;
                });
                return this.req(method, path, opts, true);
              } catch (_refreshError) {
                StorageService.clearOAuthTokens();
              }
            }
            const err = new Error(httpMessage(payload, res.status));
            err.kind = 'http';
            err.status = res.status;
            throw err;
          }
          return payload || {};
        },
        myself() { return this.req('GET', '/rest/api/3/myself'); },
        searchIssues() {
          const jql = 'assignee = currentUser() AND statusCategory != Done AND issuetype not in subTaskIssueTypes() ORDER BY updated DESC';
          return this.req('GET', '/rest/api/3/search/jql', { params: { jql, maxResults: 80, fields: 'summary,status,issuetype,attachment' } });
        },
        comments(key) { return this.req('GET', `/rest/api/3/issue/${encodeURIComponent(key)}/comment`, { params: { orderBy: '-created', maxResults: 100 } }); },
        worklogs(key) { return this.req('GET', `/rest/api/3/issue/${encodeURIComponent(key)}/worklog`); },
        addWorklog(key, body) { return this.req('POST', `/rest/api/3/issue/${encodeURIComponent(key)}/worklog`, { body }); },
        updateWorklog(key, id, body) { return this.req('PUT', `/rest/api/3/issue/${encodeURIComponent(key)}/worklog/${encodeURIComponent(id)}`, { body }); },
        deleteWorklog(key, id) { return this.req('DELETE', `/rest/api/3/issue/${encodeURIComponent(key)}/worklog/${encodeURIComponent(id)}`); }
      };

      function sanitizeUrl(url) {
        const base = String(url || '').trim().replace(/\/+$/, '');
        if (!base) return '';
        if (/^https?:\/\//i.test(base)) return base;
        return `https://${base}`;
      }

      function safeHostname(url) {
        try {
          return new URL(sanitizeUrl(url)).hostname.toLowerCase();
        } catch (_e) {
          return '';
        }
      }

      function base64UrlEncode(bytes) {
        let str = '';
        const source = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes || []);
        source.forEach((b) => { str += String.fromCharCode(b); });
        return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      }

      function parseUrlParams(urlValue) {
        try {
          const url = new URL(String(urlValue || ''));
          return {
            code: url.searchParams.get('code') || '',
            state: url.searchParams.get('state') || '',
            error: url.searchParams.get('error') || '',
            error_description: url.searchParams.get('error_description') || ''
          };
        } catch (_e) {
          return { code: '', state: '', error: '', error_description: '' };
        }
      }

      function sanitizeDebugMeta(input) {
        const secretKeys = new Set([
          'code',
          'state',
          'authorization',
          'access_token',
          'refresh_token',
          'id_token',
          'token',
          'api_token',
          'client_secret',
          'code_verifier',
          'password'
        ]);
        const walk = (value, keyName) => {
          if (keyName) {
            const key = String(keyName || '').toLowerCase();
            if (secretKeys.has(key) || key.endsWith('_token') || key.endsWith('_secret')) {
              return '[REDACTED]';
            }
          }
          if (value === null || value === undefined) {
            return value;
          }
          if (typeof value === 'string') {
            if (value.length > 160) {
              return `${value.slice(0, 160)}...`;
            }
            if (/^Bearer\s+/i.test(value)) {
              return '[REDACTED]';
            }
            return value;
          }
          if (typeof value === 'number' || typeof value === 'boolean') {
            return value;
          }
          if (Array.isArray(value)) {
            return value.slice(0, 25).map((item) => walk(item, keyName));
          }
          if (typeof value === 'object') {
            const out = {};
            Object.keys(value).slice(0, 40).forEach((k) => {
              out[k] = walk(value[k], k);
            });
            return out;
          }
          return String(value);
        };
        return walk(input, '');
      }

      function renderDebugLogs() {
        if (!el.debugLogBox) {
          return;
        }
        const lines = state.debugLogs.length ? state.debugLogs : ['(sin logs)'];
        el.debugLogBox.textContent = lines.join('\n');
      }

      function dbg(eventName, meta) {
        const stamp = new Date().toISOString();
        let line = `[${stamp}] ${eventName}`;
        if (meta !== undefined) {
          try {
            line += ` | ${JSON.stringify(sanitizeDebugMeta(meta))}`;
          } catch (_e) {
            line += ' | {"meta":"(error serializando)"}';
          }
        }
        state.debugLogs.push(line);
        if (state.debugLogs.length > DEBUG_MAX) {
          state.debugLogs = state.debugLogs.slice(state.debugLogs.length - DEBUG_MAX);
        }
        renderDebugLogs();
      }

      function openOAuthPopupWindow() {
        try {
          const popup = window.open('', 'jira_oauth_login', 'popup=yes,width=560,height=760');
          if (popup) {
            dbg('oauth_popup_opened');
          } else {
            dbg('oauth_popup_blocked');
          }
          return popup;
        } catch (error) {
          dbg('oauth_popup_error', { message: error && error.message ? error.message : String(error) });
          return null;
        }
      }

      function isOAuthPopupContext() {
        try {
          if (window.name === 'jira_oauth_login') {
            return true;
          }
          return !!(window.opener && window.opener !== window);
        } catch (_e) {
          return false;
        }
      }

      function tryCloseOAuthPopup(reason) {
        if (!isOAuthPopupContext()) {
          return false;
        }
        dbg('oauth_popup_close_attempt', { reason: String(reason || '') });
        window.setTimeout(() => {
          try {
            window.close();
            dbg('oauth_popup_close_called', { reason: String(reason || '') });
          } catch (error) {
            dbg('oauth_popup_close_failed', { reason: String(reason || ''), message: error && error.message ? error.message : String(error) });
          }
        }, 450);
        return true;
      }

      function normalizeRedirectForCompare(urlValue) {
        try {
          const url = new URL(String(urlValue || ''));
          const path = (url.pathname || '/').replace(/\/+$/, '') || '/';
          return `${url.origin}${path}`;
        } catch (_e) {
          return '';
        }
      }

      function isRedirectUriMatch(urlValue, redirectUri) {
        const left = normalizeRedirectForCompare(urlValue);
        const right = normalizeRedirectForCompare(redirectUri);
        return !!left && !!right && left === right;
      }

      function clearPopupWatcher() {
        if (state.popupWatchTimer) {
          window.clearInterval(state.popupWatchTimer);
          state.popupWatchTimer = 0;
        }
        state.popupProcessing = false;
      }

      function closePopupWindowRef(popupWindow, reason) {
        if (!popupWindow) return;
        try {
          if (popupWindow.closed) {
            dbg('oauth_popup_already_closed', { reason: String(reason || '') });
            return;
          }
        } catch (_e) {
          // ignore and try close anyway
        }
        try {
          popupWindow.close();
          dbg('oauth_popup_closed_by_parent', { reason: String(reason || '') });
        } catch (error) {
          dbg('oauth_popup_close_by_parent_failed', {
            reason: String(reason || ''),
            message: error && error.message ? error.message : String(error)
          });
        }
        window.setTimeout(() => {
          try {
            if (popupWindow && !popupWindow.closed) {
              popupWindow.close();
              dbg('oauth_popup_closed_by_parent_retry', { reason: String(reason || '') });
            }
          } catch (error) {
            dbg('oauth_popup_close_by_parent_retry_failed', {
              reason: String(reason || ''),
              message: error && error.message ? error.message : String(error)
            });
          }
        }, 700);
      }

      function watchOAuthPopupCallback(popupWindow, cfg) {
        clearPopupWatcher();
        dbg('oauth_popup_watch_start', {
          redirect_host: safeHostname(cfg.redirect_uri)
        });
        state.popupWatchTimer = window.setInterval(() => {
          if (state.popupProcessing) {
            return;
          }
          if (!popupWindow || popupWindow.closed) {
            dbg('oauth_popup_closed_before_callback');
            clearPopupWatcher();
            return;
          }
          let href = '';
          try {
            href = String(popupWindow.location.href || '');
          } catch (_e) {
            return;
          }
          if (!href || !isRedirectUriMatch(href, cfg.redirect_uri)) {
            return;
          }
          const params = parseUrlParams(href);
          if (!params.code && !params.error) {
            return;
          }
          state.popupProcessing = true;
          dbg('oauth_popup_callback_detected', {
            has_code: !!params.code,
            has_error: !!params.error
          });
          Promise.resolve(processOAuthCallback(href, false))
            .then((processed) => {
              if (processed) {
                showMsg('ok', 'Callback OAuth recibido automaticamente.');
              } else {
                showMsg('error', 'La ventana OAuth regreso sin parametros esperados.');
              }
              closePopupWindowRef(popupWindow, 'callback_processed');
            })
            .catch((error) => {
              closePopupWindowRef(popupWindow, 'callback_error');
              applyError(error, 'No se pudo procesar callback automatico.');
            })
            .finally(() => {
              clearPopupWatcher();
            });
        }, 700);
      }

      function getTopLocationHref() {
        try {
          if (window.top && window.top.location && window.top.location.href) {
            return String(window.top.location.href);
          }
        } catch (_e) {
          // ignore and fallback below
        }
        if (document.referrer) {
          return String(document.referrer);
        }
        try {
          return String(window.location.href || '');
        } catch (_e) {
          return '';
        }
      }

      function deriveDefaultRedirectUri() {
        const href = getTopLocationHref();
        if (!href) return '';
        try {
          const url = new URL(href);
          url.search = '';
          url.hash = '';
          return url.toString();
        } catch (_e) {
          return '';
        }
      }

      function clearOAuthParamsFromTopUrl() {
        const href = getTopLocationHref();
        try {
          const url = new URL(href);
          ['code', 'state', 'error', 'error_description'].forEach((key) => url.searchParams.delete(key));
          const clean = url.toString();
          try {
            if (window.top && window.top.history && typeof window.top.history.replaceState === 'function') {
              window.top.history.replaceState({}, '', clean);
              return;
            }
          } catch (_eTop) {
            // ignore
          }
          window.history.replaceState({}, '', clean);
        } catch (_e) {
          // ignore
        }
      }

      function navigateTop(urlValue, popupWindow) {
        const target = String(urlValue || '');
        if (!target) return;
        dbg('oauth_navigate_attempt', { target_host: safeHostname(target), has_popup: !!popupWindow });
        if (popupWindow && !popupWindow.closed) {
          try {
            popupWindow.location.href = target;
            if (typeof popupWindow.focus === 'function') {
              popupWindow.focus();
            }
            dbg('oauth_navigate_popup_success');
            return;
          } catch (error) {
            dbg('oauth_navigate_popup_failed', { message: error && error.message ? error.message : String(error) });
          }
        }
        try {
          const popup = window.open(target, '_blank');
          if (popup) {
            dbg('oauth_navigate_window_open_success');
            return;
          }
          dbg('oauth_navigate_window_open_blocked');
        } catch (error) {
          dbg('oauth_navigate_window_open_failed', { message: error && error.message ? error.message : String(error) });
        }
        try {
          if (window.top && window.top.location) {
            window.top.location.href = target;
            dbg('oauth_navigate_top_success');
            return;
          }
        } catch (error) {
          dbg('oauth_navigate_top_failed', { message: error && error.message ? error.message : String(error) });
        }
        try {
          window.location.href = target;
          dbg('oauth_navigate_iframe_success');
        } catch (error) {
          dbg('oauth_navigate_iframe_failed', { message: error && error.message ? error.message : String(error) });
          showMsg('error', 'No se pudo abrir la autorizacion OAuth. Permite ventanas emergentes y usa nueva pestana.');
        }
      }

      function adfToText(node) {
        if (!node) return '';
        if (typeof node === 'string') return node;
        if (Array.isArray(node)) return node.map(adfToText).join('');
        if (node.type === 'text') return node.text || '';
        if (node.type === 'hardBreak') return '\n';
        if (Array.isArray(node.content)) return node.content.map(adfToText).join('');
        return '';
      }

      function toAdf(text) {
        return {
          type: 'doc', version: 1,
          content: [{ type: 'paragraph', content: [{ type: 'text', text: String(text || '') }] }]
        };
      }

      function escapeHtml(v) {
        return String(v || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      function httpMessage(payload, status) {
        if (payload && typeof payload.error_description === 'string' && payload.error_description) {
          const errCode = typeof payload.error === 'string' && payload.error ? payload.error : 'oauth_error';
          return `${errCode}: ${payload.error_description}`;
        }
        if (payload && typeof payload.error === 'string' && payload.error) {
          return payload.error;
        }
        if (payload && Array.isArray(payload.errorMessages) && payload.errorMessages.length) return payload.errorMessages.join(' | ');
        if (payload && payload.errors && typeof payload.errors === 'object') {
          const items = Object.entries(payload.errors).map(([k, v]) => `${k}: ${v}`);
          if (items.length) return items.join(' | ');
        }
        if (payload && payload.message) return payload.message;
        return `HTTP ${status}`;
      }
      function cacheElements() {
        [
          'connPill','userPill','refreshIssuesBtn','disconnectBtn','msg','idleMsg',
          'debugLogBox','debugCopyBtn','debugClearBtn',
          'loginView','urlInp','clientIdInp','clientSecretInp','redirectUriInp','callbackUrlInp','connectBtn','processCallbackBtn','clearOAuthBtn',
          'mainView','issueSel','activityTypeSel','activityDueInp','activityInp','minutesInp','registerBtn','jiraDurationPill','timerVal','timerState','startBtn','pauseBtn',
          'resetBtn','applyTimerBtn','suggestionBox','applySugActBtn','applySugTimeBtn','registerSugBtn','todayTotal','weekTotal','issueCount','dashMeta',
          'refreshDashBtn','recentBox','commentsBox','worklogBody','timelineBox','ganttBox','genReportBtn','exportReportBtn','reportMeta',
          'reportBody','compactBtn','floatBox','floatIssue','floatTimer','floatState','floatStartBtn','floatPauseBtn','floatExpandBtn',
          'regModal','regModalMeta','regActInp','regMinInp','regModalOkBtn','regModalCancelBtn',
          'editModal','editMeta','editActInp','editDateInp','editTimeInp','editMinInp','editSaveBtn','editDeleteBtn','editCancelBtn','activityList'
        ].forEach((id) => { el[id] = document.getElementById(id); });
      }

      function uiStateSave() {
        StorageService.saveUI({
          selectedIssueKey: state.selectedIssueKey,
          activity: state.activity,
          activityType: state.activityType,
          activityDueDate: state.activityDueDate,
          durationMinutes: state.durationMinutes,
          compact: state.compact,
          lastReminderTs: state.lastReminderTs
        });
      }

      function uiStateLoad() {
        const ui = StorageService.getUI();
        state.selectedIssueKey = typeof ui.selectedIssueKey === 'string' ? ui.selectedIssueKey : '';
        state.activity = typeof ui.activity === 'string' ? ui.activity : '';
        state.activityType = OFFICIAL_ACTIVITY_TYPES.includes(String(ui.activityType || '').trim())
          ? String(ui.activityType || '').trim()
          : OFFICIAL_ACTIVITY_TYPES[0];
        state.activityDueDate = isValidInputDate(ui.activityDueDate)
          ? String(ui.activityDueDate)
          : TimeService.toInputDate(new Date());
        const parsed = parseOfficialActivity(state.activity);
        if (parsed) {
          state.activityType = parsed.type;
          state.activityDueDate = parsed.dueInput;
        } else {
          state.activity = buildOfficialActivity(state.activityType, state.activityDueDate);
        }
        state.durationMinutes = Number.isFinite(Number(ui.durationMinutes)) ? Math.max(1, Math.floor(Number(ui.durationMinutes))) : 30;
        state.compact = !!ui.compact;
        state.lastReminderTs = Number(ui.lastReminderTs || 0);
        state.lastActivityTs = StorageService.getLastActivity();
        state.activities = StorageService.getActivities();
      }

      function timerLoad() {
        const t = StorageService.getTimer();
        if (!t) return;
        state.timer.running = !!t.running;
        state.timer.resumeTs = Number(t.resumeTs || 0);
        state.timer.elapsedBizMs = Number(t.elapsedBizMs || 0);
        if (state.timer.running && !state.timer.resumeTs) state.timer.running = false;
      }

      function timerSave() { StorageService.saveTimer(state.timer); }

      function showMsg(type, text) {
        el.msg.className = `msg show ${type}`;
        el.msg.textContent = text;
      }

      function clearMsg() {
        el.msg.className = 'msg';
        el.msg.textContent = '';
      }

      function applyError(err, fallback) {
        dbg('error', {
          fallback,
          kind: err && err.kind ? err.kind : '',
          status: err && err.status ? err.status : '',
          message: err && err.message ? err.message : ''
        });
        if (err && err.kind === 'cors') {
          showMsg('error', 'No se pudo conectar a Jira desde frontend por limitacion CORS del tenant Jira Cloud.');
          return;
        }
        if (err && err.kind === 'oauth' && err.status === 400) {
          showMsg('error', `OAuth invalido. Revisa Client ID, Client Secret, Redirect URI y PKCE en Atlassian.${err && err.message ? ` Detalle: ${err.message}` : ''}`);
          return;
        }
        if (err && err.kind === 'oauth' && err.status === 401) {
          showMsg('error', `Sesion OAuth expirada o invalida. Verifica Client Secret y reconecta.${err && err.message ? ` Detalle: ${err.message}` : ''}`);
          return;
        }
        if (err && err.kind === 'http' && err.status === 401) {
          showMsg('error', 'Sesion expirada o autorizacion invalida en Jira. Reconecta con OAuth.');
          return;
        }
        if (err && err.kind === 'http' && err.status === 403) {
          showMsg('error', 'No tienes permisos suficientes en Jira para esta accion.');
          return;
        }
        showMsg('error', `${fallback}${err && err.message ? ` Detalle: ${err.message}` : ''}`);
      }

      function markActivity() {
        state.lastActivityTs = Date.now();
        state.lastReminderTs = 0;
        StorageService.saveLastActivity(state.lastActivityTs);
        uiStateSave();
      }

      function renderIdle() {
        const idle = !state.timer.running && (Date.now() - state.lastActivityTs >= INACTIVITY_MS);
        if (idle) {
          el.idleMsg.className = 'msg show info';
          el.idleMsg.textContent = 'Aviso: pasaron mas de 2 horas sin actividad registrada y el timer esta detenido.';
        } else {
          el.idleMsg.className = 'msg';
          el.idleMsg.textContent = '';
        }
      }

      function renderTop() {
        el.connPill.textContent = state.connected ? 'Conectado' : 'Sin conexion';
        el.connPill.className = `pill ${state.connected ? 'ok' : ''}`;
        el.userPill.textContent = state.connected
          ? `Usuario: ${state.me && state.me.displayName ? state.me.displayName : (state.config && state.config.url ? state.config.url : '-')}`
          : 'Usuario: -';
        el.disconnectBtn.disabled = !state.connected;
        el.refreshIssuesBtn.disabled = !state.connected;
        el.loginView.classList.toggle('hide', state.connected);
        el.mainView.classList.toggle('hide', !state.connected);
      }

      function renderActivitiesList() {
        el.activityList.innerHTML = '';
        state.activities.slice(0, 30).forEach((item) => {
          const opt = document.createElement('option');
          opt.value = item;
          el.activityList.appendChild(opt);
        });
      }

      function syncOfficialActivityToState(saveUi = true) {
        state.activityType = OFFICIAL_ACTIVITY_TYPES.includes(String(el.activityTypeSel.value || '').trim())
          ? String(el.activityTypeSel.value || '').trim()
          : OFFICIAL_ACTIVITY_TYPES[0];
        state.activityDueDate = isValidInputDate(el.activityDueInp.value)
          ? String(el.activityDueInp.value)
          : TimeService.toInputDate(new Date());
        el.activityDueInp.value = state.activityDueDate;
        state.activity = buildOfficialActivity(state.activityType, state.activityDueDate);
        el.activityInp.value = state.activity;
        if (saveUi) {
          uiStateSave();
        }
      }

      function renderOfficialActivityControls() {
        el.activityTypeSel.innerHTML = OFFICIAL_ACTIVITY_TYPES
          .map((name) => `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`)
          .join('');
        if (!OFFICIAL_ACTIVITY_TYPES.includes(state.activityType)) {
          state.activityType = OFFICIAL_ACTIVITY_TYPES[0];
        }
        if (!isValidInputDate(state.activityDueDate)) {
          state.activityDueDate = TimeService.toInputDate(new Date());
        }
        el.activityTypeSel.value = state.activityType;
        el.activityDueInp.value = state.activityDueDate;
        syncOfficialActivityToState(false);
      }

      function pushActivity(act) {
        const value = String(act || '').trim();
        if (!value) return;
        const list = [value, ...state.activities.filter((x) => x.toLowerCase() !== value.toLowerCase())].slice(0, 100);
        state.activities = list;
        StorageService.saveActivities(list);
        renderActivitiesList();
      }

      function issueByKey(key) {
        return state.issues.find((it) => it.key === key) || null;
      }

      function parseIssues(payload) {
        const list = Array.isArray(payload.issues)
          ? payload.issues
          : (Array.isArray(payload.values) ? payload.values : []);
        return list
          .filter((it) => it && it.key && it.fields && !(it.fields.issuetype && it.fields.issuetype.subtask))
          .map((it) => ({
            key: it.key,
            summary: String(it.fields.summary || ''),
            attachments: Array.isArray(it.fields.attachment) ? it.fields.attachment : []
          }));
      }

      function renderIssueSelect() {
        el.issueSel.innerHTML = '';
        if (!state.issues.length) {
          el.issueSel.innerHTML = '<option value="">Sin tickets</option>';
          state.selectedIssueKey = '';
          uiStateSave();
          renderIssueData();
          return;
        }
        state.issues.forEach((it) => {
          const opt = document.createElement('option');
          opt.value = it.key;
          opt.textContent = `${it.key} - ${it.summary}`;
          el.issueSel.appendChild(opt);
        });
        if (!state.issues.some((it) => it.key === state.selectedIssueKey)) {
          state.selectedIssueKey = state.issues[0].key;
        }
        el.issueSel.value = state.selectedIssueKey;
        uiStateSave();
      }

      function timerBusinessMsNow() {
        let total = state.timer.elapsedBizMs;
        if (state.timer.running) {
          total += TimeService.businessMsBetween(new Date(state.timer.resumeTs), new Date());
        }
        return total;
      }

      function timerStateLabel() {
        if (!state.timer.running) return 'inactivo';
        return TimeService.isBusinessNow(new Date()) ? 'en curso' : 'en curso fuera de horario';
      }

      function renderTimer() {
        const ms = timerBusinessMsNow();
        const label = timerStateLabel();
        const value = TimeService.hhmmss(ms);
        el.timerVal.textContent = value;
        el.timerState.textContent = `Estado: ${label}`;
        el.floatTimer.textContent = value;
        el.floatState.textContent = `Estado: ${label}`;
      }

      function timerStart() {
        if (state.timer.running) return;
        state.timer.running = true;
        state.timer.resumeTs = Date.now();
        timerSave();
        markActivity();
        renderTimer();
      }

      function timerPause() {
        if (!state.timer.running) return;
        state.timer.elapsedBizMs += TimeService.businessMsBetween(new Date(state.timer.resumeTs), new Date());
        state.timer.running = false;
        state.timer.resumeTs = 0;
        timerSave();
        markActivity();
        renderTimer();
      }

      function timerReset() {
        state.timer.running = false;
        state.timer.resumeTs = 0;
        state.timer.elapsedBizMs = 0;
        timerSave();
        markActivity();
        renderTimer();
      }

      function applyTimerToMinutes() {
        const mins = Math.max(1, Math.ceil(timerBusinessMsNow() / 60000));
        state.durationMinutes = mins;
        el.minutesInp.value = String(mins);
        renderDurationPill();
        uiStateSave();
      }

      function renderDurationPill() {
        const mins = Math.max(1, Math.floor(Number(state.durationMinutes || 0)));
        el.jiraDurationPill.textContent = TimeService.jiraDuration(mins);
      }

      function renderCompact() {
        el.floatIssue.textContent = state.selectedIssueKey || '-';
        el.floatBox.classList.toggle('show', state.connected && state.compact);
        el.compactBtn.textContent = state.compact ? 'Expandir vista' : 'Modo compacto';
      }

      function commentText(c) { return adfToText(c && c.body ? c.body : ''); }
      function worklogText(w) { return adfToText(w && w.comment ? w.comment : ''); }
      function mine(author) { return !!(author && state.me && String(author.accountId || '') === String(state.me.accountId || '')); }
      function minutesOf(worklog) { return Math.max(1, Math.round(Number(worklog && worklog.timeSpentSeconds ? worklog.timeSpentSeconds : 0) / 60)); }

      function activityFromText(text) {
        const t = String(text || '').trim();
        if (!t) return '';
        const m = t.match(/^\[([^\]]+)\]/);
        if (m && m[1]) return m[1].trim();
        return (t.split(/\r?\n/)[0] || '').trim().slice(0, 80);
      }

      function activityOf(worklog) {
        return activityFromText(worklogText(worklog)) || 'Sin actividad';
      }

      function normalizePlain(text) {
        return String(text || '')
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '')
          .toLowerCase();
      }

      function inferOfficialActivityType(sourceText) {
        const normalized = normalizePlain(sourceText);
        for (const name of OFFICIAL_ACTIVITY_TYPES) {
          const n = normalizePlain(name);
          if (normalized.includes(n)) return name;
        }
        if (normalized.includes('agente') && normalized.includes('exito')) return 'Configuración Agente de Éxito';
        if (normalized.includes('estandarizacion') && normalized.includes('plantilla')) return 'Estandarización de plantillas';
        if (normalized.includes('docente') && normalized.includes('plantilla')) return 'Entrega de plantillas DOCENTES Coach/Farmer/Hunter';
        if (normalized.includes('estudiante') && normalized.includes('plantilla')) return 'Entrega de plantillas ESTUDIANTES Coach/Farmer/Hunter';
        if (normalized.includes('pendiente')) return 'Pendiente información';
        if (normalized.includes('integracion') && normalized.includes('lql')) return 'Integración LQL';
        if (normalized.includes('integracion') && normalized.includes('rlp')) return 'Integración RLP';
        if (normalized.includes('integracion') && normalized.includes('ldb')) return 'Integración LDB';
        if (normalized.includes('integracion') && normalized.includes('wemath')) return 'Integración WeMath';
        if (normalized.includes('integracion') && normalized.includes('pleno')) return 'Integración Pleno';
        if (normalized.includes('integracion') && normalized.includes('studio')) return 'Integración Studio';
        if (normalized.includes('configuracion') && normalized.includes('colegio')) return 'Configuración de colegio';
        if (normalized.includes('configuracion') && normalized.includes('docente')) return 'Configuración de docentes';
        if (normalized.includes('configuracion') && normalized.includes('estudiante')) return 'Configuración de estudiantes';
        return OFFICIAL_ACTIVITY_TYPES[0];
      }

      function sortDesc(items, dateFn) {
        return items.slice().sort((a, b) => new Date(dateFn(b)).getTime() - new Date(dateFn(a)).getTime());
      }

      function renderComments(issueKey) {
        const comments = state.commentsByIssue[issueKey] || [];
        if (!comments.length) {
          el.commentsBox.innerHTML = '<div class="empty">Sin comentarios.</div>';
          return;
        }
        el.commentsBox.innerHTML = comments.map((c) => {
          const my = mine(c.author);
          const author = c.author && c.author.displayName ? c.author.displayName : 'Sin autor';
          const txt = commentText(c) || '(sin texto)';
          return `
            <div class="comment ${my ? 'mine' : ''}">
              <div class="meta"><span>${escapeHtml(author)}</span><span>${escapeHtml(TimeService.dtLabel(c.created))}</span></div>
              <div class="body">${escapeHtml(txt)}</div>
              <div class="row" style="margin-top:8px;"><button class="btn" data-act="reg-from-comment" data-id="${escapeHtml(String(c.id))}">Registrar actividad</button></div>
            </div>
          `;
        }).join('');
      }
      function renderWorklogs(issueKey) {
        const rows = state.worklogsByIssue[issueKey] || [];
        if (!rows.length) {
          el.worklogBody.innerHTML = '<tr><td colspan="5"><div class="empty">Sin worklogs.</div></td></tr>';
          return;
        }
        el.worklogBody.innerHTML = rows.map((w) => {
          const my = mine(w.author);
          const author = w.author && w.author.displayName ? w.author.displayName : 'Sin autor';
          const date = TimeService.dtLabel(w.started || w.created || new Date());
          const act = activityOf(w);
          const mins = TimeService.jiraDuration(minutesOf(w));
          const actions = my
            ? `<button class="btn" data-act="edit-worklog" data-id="${escapeHtml(String(w.id))}">Editar</button> <button class="btn danger" data-act="del-worklog" data-id="${escapeHtml(String(w.id))}">Eliminar</button>`
            : '<span class="pill">Solo lectura</span>';
          return `<tr><td>${escapeHtml(date)}</td><td>${escapeHtml(act)}</td><td>${escapeHtml(mins)}</td><td>${escapeHtml(author)}</td><td>${actions}</td></tr>`;
        }).join('');
      }

      function suggestionFor(issueKey) {
        const comments = state.commentsByIssue[issueKey] || [];
        const worklogs = state.worklogsByIssue[issueKey] || [];
        if (!comments.length || !state.me) return null;
        const commentsAsc = comments
          .slice()
          .filter((c) => c && c.created)
          .sort((a, b) => new Date(a.created).getTime() - new Date(b.created).getTime());
        const myLogs = worklogs
          .slice()
          .filter((w) => mine(w.author))
          .sort((a, b) => new Date(a.started || a.created || 0).getTime() - new Date(b.started || b.created || 0).getTime());
        const pending = [];
        for (let i = 0; i < commentsAsc.length; i += 1) {
          const c = commentsAsc[i];
          const cTs = new Date(c.created).getTime();
          const nextTs = i < commentsAsc.length - 1
            ? new Date(commentsAsc[i + 1].created).getTime()
            : Number.POSITIVE_INFINITY;
          if (!Number.isFinite(cTs)) continue;
          const registered = myLogs.some((w) => {
            const wTs = new Date(w.started || w.created || 0).getTime();
            return Number.isFinite(wTs) && wTs >= cTs && wTs < nextTs;
          });
          if (!registered) {
            pending.push(c);
          }
        }
        if (pending.length) {
          const c = pending[pending.length - 1];
          const suggestedType = inferOfficialActivityType(commentText(c));
          const mins = Math.max(5, Math.min(480, TimeService.businessMinutesBetween(new Date(c.created), new Date())));
          return {
            commentId: c.id,
            created: c.created,
            author: c.author && c.author.displayName ? c.author.displayName : 'Sin autor',
            activity: suggestedType,
            activityType: suggestedType,
            minutes: mins
          };
        }
        return null;
      }

      function renderSuggestion(issueKey) {
        state.suggestion = suggestionFor(issueKey);
        if (!state.suggestion) {
          el.suggestionBox.className = 'empty';
          el.suggestionBox.textContent = 'No hay sugerencias pendientes.';
          el.applySugActBtn.disabled = true;
          el.applySugTimeBtn.disabled = true;
          el.registerSugBtn.disabled = true;
          return;
        }
        const s = state.suggestion;
        el.suggestionBox.className = 'msg show info';
        el.suggestionBox.innerHTML = `Comentario pendiente detectado.<br>Autor: <strong>${escapeHtml(s.author || 'Sin autor')}</strong><br>Actividad sugerida: <strong>${escapeHtml(s.activity)}</strong><br>Tiempo: <strong>${escapeHtml(TimeService.jiraDuration(s.minutes))}</strong><br>Fecha comentario: ${escapeHtml(TimeService.dtLabel(s.created))}`;
        el.applySugActBtn.disabled = false;
        el.applySugTimeBtn.disabled = false;
        el.registerSugBtn.disabled = false;
      }

      function renderTimeline(issueKey) {
        const key = String(issueKey || '').trim();
        const issue = issueByKey(key);
        const logs = sortDesc((state.worklogsByIssue[key] || []).slice(), (w) => w.started || w.created).reverse();

        if (!key || !logs.length) {
          el.timelineBox.className = 'empty';
          el.timelineBox.textContent = 'Sin registros para este ticket.';
          el.ganttBox.className = 'empty';
          el.ganttBox.textContent = 'Sin registros para este ticket.';
          return;
        }

        const start = Math.min(...logs.map((w) => new Date(w.started || w.created).getTime()));
        const end = Math.max(...logs.map((w) => new Date(w.started || w.created).getTime() + minutesOf(w) * 60000));
        const range = Math.max(1, end - start);

        const legendMap = {};
        const totalMinutes = logs.reduce((acc, w) => acc + minutesOf(w), 0);
        const segmentsHtml = logs.map((w) => {
          const st = new Date(w.started || w.created).getTime();
          const mins = minutesOf(w);
          const dur = Math.max(60000, mins * 60000);
          const act = activityOf(w) || 'Sin actividad';
          const color = activityColor(act);
          legendMap[act] = legendMap[act] || { activity: act, minutes: 0, color };
          legendMap[act].minutes += mins;
          const left = ((st - start) / range) * 100;
          const width = Math.max(1.8, (dur / range) * 100);
          const author = w.author && w.author.displayName ? w.author.displayName : 'Sin autor';
          const meta = `${key} | ${author} | ${act} | ${TimeService.jiraDuration(mins)} | ${TimeService.dtLabel(st)}`;
          return `<span class="timeline-ticket-segment" title="${escapeHtml(meta)}" style="left:${left.toFixed(3)}%;width:${width.toFixed(3)}%;background:${escapeHtml(color)};"></span>`;
        }).join('');

        const label = issue && issue.summary ? `${key} - ${issue.summary}` : key;
        const legendEntries = Object.values(legendMap).sort((a, b) => b.minutes - a.minutes);
        const legendHtml = legendEntries.length
          ? `<div class="activity-legend">${legendEntries.map((it) => `<span class="activity-legend-item" title="${escapeHtml(`${it.activity}: ${TimeService.jiraDuration(it.minutes)}`)}"><span class="activity-legend-dot" style="background:${escapeHtml(it.color)};"></span>${escapeHtml(it.activity)} (${escapeHtml(TimeService.jiraDuration(it.minutes))})</span>`).join('')}</div>`
          : '';

        el.timelineBox.className = '';
        el.timelineBox.innerHTML = `
          <div class="timeline-axis">
            <span>Inicio: ${escapeHtml(TimeService.dtLabel(start))}</span>
            <span>Fin: ${escapeHtml(TimeService.dtLabel(end))}</span>
          </div>
          <div class="timeline-ticket-list">
            <div class="timeline-ticket-row">
              <div class="timeline-ticket-label" title="${escapeHtml(label)}">${escapeHtml(label)}</div>
              <div class="timeline-ticket-track">${segmentsHtml}</div>
              <div class="timeline-ticket-total">${escapeHtml(TimeService.jiraDuration(totalMinutes))}</div>
            </div>
          </div>
          ${legendHtml}
        `;

        const entries = legendEntries;
        const max = entries[0] ? entries[0].minutes : 1;
        el.ganttBox.className = '';
        el.ganttBox.innerHTML = entries.map((it) => {
          const width = Math.max(3, (it.minutes / max) * 100);
          const jiraDur = TimeService.jiraDuration(it.minutes);
          return `<div class="gantt-row" title="${escapeHtml(`${it.activity}: ${jiraDur}`)}"><div>${escapeHtml(it.activity)}</div><div class="track"><span class="bar" style="left:0;width:${width.toFixed(2)}%;background:${escapeHtml(it.color)};"></span></div><div style="text-align:right;color:#5f7287;">${escapeHtml(jiraDur)}</div></div>`;
        }).join('');
      }

      function renderIssueData() {
        const key = state.selectedIssueKey;
        if (!key) {
          renderComments('');
          renderWorklogs('');
          renderSuggestion('');
          renderTimeline('');
          return;
        }
        renderComments(key);
        renderWorklogs(key);
        renderSuggestion(key);
        renderTimeline(key);
      }

      function renderDashboard() {
        if (!FEATURES.dashboard) return;
        el.todayTotal.textContent = TimeService.jiraDuration(state.dash.today);
        el.weekTotal.textContent = TimeService.jiraDuration(state.dash.week);
        el.issueCount.textContent = String(state.dash.issueCount);
        el.dashMeta.textContent = state.dash.refreshedAt ? `Actualizado: ${TimeService.dtLabel(state.dash.refreshedAt)}` : 'Sin datos.';
        if (!state.dash.logs.length) {
          el.recentBox.className = 'empty';
          el.recentBox.textContent = 'Sin historial reciente.';
          return;
        }
        el.recentBox.className = '';
        el.recentBox.innerHTML = state.dash.logs.slice(0, 15).map((w) => {
          const line = `${w.issueKey} | ${activityOf(w)}`;
          const right = `${TimeService.jiraDuration(minutesOf(w))} - ${TimeService.dtLabel(w.started || w.created)}`;
          return `<div class="row" style="justify-content:space-between;border-bottom:1px solid #eef3f9;padding:6px 0;"><span class="recent-line">${escapeHtml(line)}</span><span class="muted">${escapeHtml(right)}</span></div>`;
        }).join('');
      }

      function normalizeSchool(summary) {
        const raw = String(summary || '').trim();
        if (!raw) return 'SIN_COLEGIO';
        const clean = raw.normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\[[^\]]+\]/g, ' ').replace(/\s+/g, ' ').trim().toUpperCase();
        if (!clean) return 'SIN_COLEGIO';
        return (clean.split(/\s*[-|:;/]\s*/)[0] || clean).slice(0, 80).trim() || 'SIN_COLEGIO';
      }

      function uniqueStrings(list) {
        const seen = new Set();
        const out = [];
        (list || []).forEach((v) => {
          const t = String(v || '').trim();
          if (!t) return;
          const k = t.toLowerCase();
          if (seen.has(k)) return;
          seen.add(k);
          out.push(t);
        });
        return out;
      }

      function xlsxTokens(text) {
        const src = String(text || '');
        const rg = /([A-Za-z0-9_\-./%() ]+\.xlsx)\b/gi;
        const out = [];
        let m = rg.exec(src);
        while (m) {
          out.push(m[1].trim());
          m = rg.exec(src);
        }
        return uniqueStrings(out);
      }

      function renderReport() {
        if (!FEATURES.report) return;
        const g = state.report.grouped || [];
        el.exportReportBtn.disabled = !g.length;
        if (!g.length) {
          el.reportBody.innerHTML = '<tr><td colspan="4"><div class="empty">Sin resultados.</div></td></tr>';
          if (!(state.report.detail || []).length) el.reportMeta.textContent = 'Sin reporte.';
          return;
        }
        el.reportBody.innerHTML = g.map((it) => `<tr><td>${escapeHtml(it.colegio)}</td><td>${it.tickets}</td><td>${it.comentarios}</td><td>${it.adjuntos_xlsx}</td></tr>`).join('');
        el.reportMeta.textContent = `Detalle detectado: ${state.report.detail.length} comentarios.`;
      }

      async function mapLimit(items, limit, fn) {
        const size = Math.max(1, Math.min(limit, items.length));
        let idx = 0;
        const workers = Array.from({ length: size }, async () => {
          while (true) {
            const cur = idx;
            idx += 1;
            if (cur >= items.length) break;
            await fn(items[cur], cur);
          }
        });
        await Promise.all(workers);
      }

      async function refreshDashboard() {
        if (!FEATURES.dashboard) {
          return;
        }
        if (!state.connected || !state.issues.length) {
          state.dash = { logs: [], today: 0, week: 0, issueCount: 0, refreshedAt: null };
          renderDashboard();
          return;
        }
        await mapLimit(state.issues.map((i) => i.key), 4, async (key) => {
          try {
            const payload = await JiraService.worklogs(key);
            const list = Array.isArray(payload.worklogs) ? payload.worklogs : [];
            state.worklogsByIssue[key] = sortDesc(list, (w) => w.started || w.created || '');
          } catch (_e) {
            if (!state.worklogsByIssue[key]) state.worklogsByIssue[key] = [];
          }
        });
        const all = [];
        const today = TimeService.startOfToday().getTime();
        const week = TimeService.startOfWeek().getTime();
        let todayMin = 0;
        let weekMin = 0;
        const issueSet = new Set();
        state.issues.forEach((issue) => {
          (state.worklogsByIssue[issue.key] || []).forEach((w) => {
            if (!mine(w.author)) return;
            const ts = new Date(w.started || w.created || 0).getTime();
            const mins = minutesOf(w);
            if (ts >= today) todayMin += mins;
            if (ts >= week) weekMin += mins;
            issueSet.add(issue.key);
            all.push(Object.assign({}, w, { issueKey: issue.key }));
          });
        });
        state.dash = {
          logs: sortDesc(all, (w) => w.started || w.created || ''),
          today: todayMin,
          week: weekMin,
          issueCount: issueSet.size,
          refreshedAt: new Date()
        };
        renderDashboard();
      }
      async function generateReport() {
        if (!FEATURES.report) {
          return;
        }
        if (!state.connected || !state.issues.length) {
          showMsg('error', 'No hay tickets cargados para generar reporte.');
          return;
        }
        showMsg('info', 'Generando reporte de comentarios...');
        const detail = [];
        await mapLimit(state.issues, 4, async (issue) => {
          let comments = state.commentsByIssue[issue.key];
          if (!comments) {
            try {
              const payload = await JiraService.comments(issue.key);
              comments = sortDesc(Array.isArray(payload.comments) ? payload.comments : [], (c) => c.created || '');
              state.commentsByIssue[issue.key] = comments;
            } catch (_e) {
              comments = [];
            }
          }
          const issueXlsx = uniqueStrings((issue.attachments || []).map((a) => (a && a.filename ? String(a.filename) : '')).filter((name) => /\.xlsx$/i.test(name)));
          comments.forEach((c) => {
            const text = commentText(c);
            if (!text.toLowerCase().includes('plantilla')) return;
            const merged = uniqueStrings([ ...xlsxTokens(text), ...issueXlsx ]);
            if (!merged.length) return;
            detail.push({
              colegio: normalizeSchool(issue.summary),
              issue_key: issue.key,
              issue_summary: issue.summary || '',
              comment_id: c.id,
              author: c.author && c.author.displayName ? c.author.displayName : '',
              created: TimeService.dtLabel(c.created),
              actividad_sugerida: activityFromText(text),
              adjuntos_xlsx: merged.join(' | '),
              comentario: text.replace(/\s+/g, ' ').trim().slice(0, 240)
            });
          });
        });
        const map = {};
        detail.forEach((row) => {
          const k = row.colegio || 'SIN_COLEGIO';
          if (!map[k]) map[k] = { colegio: k, ticketsSet: new Set(), comentarios: 0, adjuntos: 0 };
          map[k].ticketsSet.add(row.issue_key);
          map[k].comentarios += 1;
          map[k].adjuntos += String(row.adjuntos_xlsx || '').split('|').filter((x) => x.trim()).length;
        });
        const grouped = Object.values(map).map((it) => ({
          colegio: it.colegio,
          tickets: it.ticketsSet.size,
          comentarios: it.comentarios,
          adjuntos_xlsx: it.adjuntos
        })).sort((a, b) => b.comentarios - a.comentarios);
        state.report = { detail, grouped };
        renderReport();
        showMsg(detail.length ? 'ok' : 'info', detail.length ? `Reporte generado (${detail.length} comentarios detectados).` : 'No se detectaron comentarios con plantilla + .xlsx.');
      }

      function exportReport() {
        if (!FEATURES.report) {
          return;
        }
        if (!state.report.detail.length) {
          showMsg('error', 'Primero genera el reporte.');
          return;
        }
        if (!window.XLSX || !window.XLSX.utils) {
          showMsg('error', 'No se pudo cargar libreria XLSX en el navegador.');
          return;
        }
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(state.report.detail), 'Detalle');
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(state.report.grouped), 'PorColegio');
        const stamp = TimeService.toInputDate(new Date()).replace(/-/g, '');
        XLSX.writeFile(wb, `jira_reporte_plantillas_${stamp}.xlsx`);
      }

      async function loadIssueData(issueKey) {
        if (!issueKey) return;
        const [c, w] = await Promise.all([JiraService.comments(issueKey), JiraService.worklogs(issueKey)]);
        const comments = sortDesc(Array.isArray(c.comments) ? c.comments : [], (x) => x.created || '');
        const worklogs = sortDesc(Array.isArray(w.worklogs) ? w.worklogs : [], (x) => x.started || x.created || '');
        state.commentsByIssue[issueKey] = comments;
        state.worklogsByIssue[issueKey] = worklogs;
        renderIssueData();
      }

      async function loadIssues() {
        const payload = await JiraService.searchIssues();
        state.issues = parseIssues(payload);
        renderIssueSelect();
        if (state.selectedIssueKey) await loadIssueData(state.selectedIssueKey);
        else renderIssueData();
      }

      async function createWorklog(issueKey, activity, minutes, explicitStarted = null) {
        const key = String(issueKey || '').trim();
        const act = String(activity || '').trim();
        const mins = Math.max(0, Math.floor(Number(minutes || 0)));
        if (!key) { showMsg('error', 'Selecciona un ticket.'); return; }
        if (!act) { showMsg('error', 'Ingresa una actividad.'); return; }
        if (!mins) { showMsg('error', 'Duracion invalida.'); return; }
        const started = explicitStarted instanceof Date ? explicitStarted : TimeService.subtractBusinessMinutes(new Date(), mins);
        const payload = {
          started: TimeService.jiraDateTime(started),
          timeSpentSeconds: mins * 60,
          comment: toAdf(worklogCommentFromActivity(act, started))
        };
        await JiraService.addWorklog(key, payload);
        pushActivity(act);
        markActivity();
        timerReset();
        await loadIssueData(key);
        await refreshDashboard();
        showMsg('ok', `Worklog registrado (${TimeService.jiraDuration(mins)}).`);
      }

      async function updateWorklog(issueKey, worklogId, activity, dateObj, minutes) {
        const key = String(issueKey || '').trim();
        const id = String(worklogId || '').trim();
        const act = String(activity || '').trim();
        const mins = Math.max(0, Math.floor(Number(minutes || 0)));
        if (!key || !id || !act || !mins || !(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) {
          showMsg('error', 'Datos incompletos para editar worklog.');
          return;
        }
        const payload = {
          started: TimeService.jiraDateTime(dateObj),
          timeSpentSeconds: mins * 60,
          comment: toAdf(worklogCommentFromActivity(act, dateObj))
        };
        await JiraService.updateWorklog(key, id, payload);
        pushActivity(act);
        markActivity();
        await loadIssueData(key);
        await refreshDashboard();
        showMsg('ok', 'Worklog actualizado.');
      }

      async function deleteWorklog(issueKey, worklogId) {
        await JiraService.deleteWorklog(issueKey, worklogId);
        markActivity();
        await loadIssueData(issueKey);
        await refreshDashboard();
        showMsg('ok', 'Worklog eliminado.');
      }

      function readConfigInputs() {
        return {
          url: sanitizeUrl(el.urlInp.value),
          client_id: String(el.clientIdInp.value || '').trim(),
          client_secret: String(el.clientSecretInp.value || ''),
          redirect_uri: String(el.redirectUriInp.value || '').trim(),
          cloud_id: ''
        };
      }

      function applyConfigToInputs(cfg) {
        if (!cfg) return;
        el.urlInp.value = cfg.url || '';
        el.clientIdInp.value = cfg.client_id || '';
        el.clientSecretInp.value = cfg.client_secret || '';
        el.redirectUriInp.value = cfg.redirect_uri || deriveDefaultRedirectUri();
      }

      function isLikelyWrongRedirectUri(jiraUrl, redirectUri) {
        const jiraHost = safeHostname(jiraUrl);
        const redirectHost = safeHostname(redirectUri);
        if (!jiraHost || !redirectHost) return false;
        return jiraHost === redirectHost;
      }

      function resetConnectionState() {
        state.connected = false;
        state.config = null;
        state.me = null;
        state.issues = [];
        state.selectedIssueKey = '';
        state.commentsByIssue = {};
        state.worklogsByIssue = {};
        state.report = { detail: [], grouped: [] };
        state.dash = { logs: [], today: 0, week: 0, issueCount: 0, refreshedAt: null };
        JiraService.setCloudId('');
      }

      async function resolveCloudId(cfg, tokens) {
        if (cfg.cloud_id) {
          return cfg.cloud_id;
        }
        const resources = await OAuthService.getResources(tokens.access_token);
        dbg('oauth_resources_loaded', { count: resources.length });
        const resource = OAuthService.pickCloudResource(resources, cfg.url);
        const cloudId = String(resource.id || '').trim();
        if (!cloudId) {
          const err = new Error('No se pudo resolver cloudId para Jira.');
          err.kind = 'oauth';
          err.status = 404;
          throw err;
        }
        return cloudId;
      }

      async function connectWithStoredSession(cfg, persistConfig) {
        const effective = {
          url: sanitizeUrl(cfg.url || ''),
          client_id: String(cfg.client_id || '').trim(),
          client_secret: String(cfg.client_secret || ''),
          redirect_uri: String(cfg.redirect_uri || '').trim(),
          cloud_id: String(cfg.cloud_id || '').trim()
        };
        if (!effective.url || !effective.client_id || !effective.client_secret || !effective.redirect_uri) {
          const err = new Error('Configuracion OAuth incompleta.');
          err.kind = 'oauth';
          err.status = 400;
          throw err;
        }
        dbg('connect_with_session_start', {
          jira_host: safeHostname(effective.url),
          redirect_host: safeHostname(effective.redirect_uri),
          has_cloud_id: !!effective.cloud_id
        });
        const tokens = await OAuthService.ensureValidTokens(effective);
        if (!effective.cloud_id) {
          effective.cloud_id = await resolveCloudId(effective, tokens);
        }
        if (persistConfig) {
          StorageService.saveConfig(effective);
        }
        JiraService.setCloudId(effective.cloud_id);
        const me = await JiraService.myself();
        state.connected = true;
        state.config = effective;
        state.me = me;
        renderTop();
        await loadIssues();
        await refreshDashboard();
        dbg('connect_with_session_ok', { issue_count: state.issues.length });
      }

      async function processOAuthCallback(callbackUrl, clearTopUrl) {
        if (state.oauthCallbackInProgress) {
          dbg('oauth_callback_skip_in_progress');
          return false;
        }
        state.oauthCallbackInProgress = true;
        const params = parseUrlParams(callbackUrl);
        dbg('oauth_callback_detected', {
          has_code: !!params.code,
          has_error: !!params.error,
          clear_top_url: !!clearTopUrl
        });
        try {
          if (!params.code && !params.error) {
            return false;
          }
          if (params.error) {
            StorageService.clearOAuthPending();
            if (clearTopUrl) {
              clearOAuthParamsFromTopUrl();
            }
            const err = new Error(params.error_description || params.error);
            err.kind = 'oauth';
            err.status = 400;
            throw err;
          }
          const pending = StorageService.getOAuthPending();
          if (!pending) {
            if (StorageService.getOAuthTokens()) {
              dbg('oauth_callback_pending_missing_but_tokens_exist');
              if (clearTopUrl) {
                clearOAuthParamsFromTopUrl();
              }
              tryCloseOAuthPopup('callback_already_processed');
              return true;
            }
            const err = new Error('No hay estado OAuth pendiente. Inicia nuevamente la conexion.');
            err.kind = 'oauth';
            err.status = 400;
            throw err;
          }
          if (String(params.state || '') !== String(pending.state || '')) {
            StorageService.clearOAuthPending();
            const err = new Error('State OAuth invalido. Posible callback de otra sesion.');
            err.kind = 'oauth';
            err.status = 400;
            throw err;
          }
          const cfg = StorageService.getConfig();
          if (!cfg) {
            const err = new Error('No existe configuracion local para completar OAuth.');
            err.kind = 'oauth';
            err.status = 400;
            throw err;
          }
          const tokenPayload = await OAuthService.exchangeCode(cfg, params.code, String(pending.code_verifier || ''));
          StorageService.saveOAuthTokens(tokenPayload);
          StorageService.clearOAuthPending();
          dbg('oauth_callback_token_saved', { has_refresh: !!tokenPayload.refresh_token });
          if (clearTopUrl) {
            clearOAuthParamsFromTopUrl();
          }
          let postConnectError = null;
          try {
            await connectWithStoredSession(cfg, true);
          } catch (error) {
            postConnectError = error;
            dbg('oauth_callback_post_connect_error', {
              kind: error && error.kind ? error.kind : '',
              status: error && error.status ? error.status : '',
              message: error && error.message ? error.message : ''
            });
          }
          StorageService.markOAuthDone('callback');
          dbg('oauth_callback_completed', {
            connected: state.connected,
            has_post_error: !!postConnectError
          });
          tryCloseOAuthPopup('callback_completed');
          if (postConnectError) {
            throw postConnectError;
          }
          return true;
        } finally {
          state.oauthCallbackInProgress = false;
        }
      }

      function bind() {
        window.addEventListener('storage', async (event) => {
          if (!event || event.key !== STORAGE.oauthDone || !event.newValue) {
            return;
          }
          dbg('oauth_done_storage_event');
          if (state.connected) {
            return;
          }
          try {
            await autoReconnect();
          } catch (_e) {
            // autoReconnect already handles UI/errors
          }
        });

        el.debugClearBtn.addEventListener('click', () => {
          state.debugLogs = [];
          renderDebugLogs();
        });
        el.debugCopyBtn.addEventListener('click', async () => {
          const payload = (state.debugLogs || []).join('\n');
          try {
            await navigator.clipboard.writeText(payload);
            showMsg('info', 'Logs copiados al portapapeles.');
          } catch (_e) {
            showMsg('error', 'No se pudo copiar logs. Copia manual desde el panel.');
          }
        });

        el.connectBtn.addEventListener('click', async () => {
          clearMsg();
          const cfg = readConfigInputs();
          if (!cfg.redirect_uri) {
            cfg.redirect_uri = deriveDefaultRedirectUri();
            el.redirectUriInp.value = cfg.redirect_uri;
          }
          if (!cfg.url || !cfg.client_id || !cfg.client_secret || !cfg.redirect_uri) {
            showMsg('error', 'Completa URL Jira, Client ID, Client Secret y Redirect URI.');
            return;
          }
          if (isLikelyWrongRedirectUri(cfg.url, cfg.redirect_uri)) {
            showMsg(
              'error',
              'El Redirect URI no debe ser la URL de Jira. Usa la URL de esta app (la donde esta abierto este modulo) y registrala en Atlassian OAuth.'
            );
            dbg('oauth_invalid_redirect_uri', {
              jira_host: safeHostname(cfg.url),
              redirect_host: safeHostname(cfg.redirect_uri)
            });
            return;
          }
          StorageService.saveConfig(cfg);
          StorageService.clearOAuthTokens();
          StorageService.clearOAuthPending();
          StorageService.clearOAuthDone();
          clearPopupWatcher();
          const popupWindow = openOAuthPopupWindow();
          if (!popupWindow) {
            showMsg('error', 'El navegador bloqueo la ventana OAuth. Permite popups para este sitio e intenta de nuevo.');
            return;
          }
          try {
            await OAuthService.startAuth(cfg, popupWindow);
            watchOAuthPopupCallback(popupWindow, cfg);
            showMsg('info', 'Se abrio una nueva pestaña/ventana para autorizacion OAuth.');
          } catch (e) {
            try { popupWindow.close(); } catch (_closeErr) { /* ignore */ }
            clearPopupWatcher();
            applyError(e, 'No fue posible iniciar OAuth.');
          }
        });

        el.clearOAuthBtn.addEventListener('click', () => {
          clearPopupWatcher();
          StorageService.clearOAuthTokens();
          StorageService.clearOAuthPending();
          StorageService.clearOAuthDone();
          StorageService.del(STORAGE.config);
          resetConnectionState();
          renderTop();
          renderIssueSelect();
          renderIssueData();
          renderDashboard();
          renderReport();
          showMsg('info', 'Sesion OAuth local limpiada.');
        });

        el.processCallbackBtn.addEventListener('click', async () => {
          clearMsg();
          const raw = String(el.callbackUrlInp.value || '').trim();
          dbg('oauth_process_callback_clicked', { has_url: !!raw });
          if (!raw) {
            showMsg('error', 'Pega la URL completa de callback para procesarla.');
            return;
          }
          if (!StorageService.getConfig()) {
            const cfg = readConfigInputs();
            if (!cfg.redirect_uri) {
              cfg.redirect_uri = deriveDefaultRedirectUri();
              el.redirectUriInp.value = cfg.redirect_uri;
            }
            if (cfg.url && cfg.client_id && cfg.client_secret && cfg.redirect_uri) {
              StorageService.saveConfig(cfg);
            }
          }
          try {
            const processed = await processOAuthCallback(raw, false);
            if (!processed) {
              showMsg('error', 'La URL no contiene parametros OAuth (code/state/error). Pega la URL completa de retorno.');
              return;
            }
            showMsg('ok', 'Callback OAuth procesado correctamente.');
          } catch (e) {
            resetConnectionState();
            renderTop();
            applyError(e, 'No se pudo procesar el callback OAuth.');
          }
        });

        el.disconnectBtn.addEventListener('click', () => {
          clearPopupWatcher();
          StorageService.del(STORAGE.config);
          StorageService.clearOAuthTokens();
          StorageService.clearOAuthPending();
          StorageService.clearOAuthDone();
          resetConnectionState();
          renderTop();
          renderIssueSelect();
          renderIssueData();
          renderDashboard();
          renderReport();
          clearMsg();
        });

        el.refreshIssuesBtn.addEventListener('click', async () => {
          if (!state.connected) return;
          try { await loadIssues(); await refreshDashboard(); showMsg('ok', 'Tickets actualizados.'); }
          catch (e) { applyError(e, 'No se pudieron recargar tickets.'); }
        });

        el.issueSel.addEventListener('change', async () => {
          state.selectedIssueKey = String(el.issueSel.value || '');
          uiStateSave();
          if (!state.selectedIssueKey) { renderIssueData(); return; }
          try { await loadIssueData(state.selectedIssueKey); }
          catch (e) { applyError(e, `No se pudo cargar detalle de ${state.selectedIssueKey}.`); }
          renderCompact();
        });

        el.activityTypeSel.addEventListener('change', () => {
          syncOfficialActivityToState(true);
        });
        el.activityDueInp.addEventListener('change', () => {
          syncOfficialActivityToState(true);
        });
        el.minutesInp.addEventListener('input', () => {
          state.durationMinutes = Math.max(1, Math.floor(Number(el.minutesInp.value || 0)));
          el.minutesInp.value = String(state.durationMinutes);
          uiStateSave();
          renderDurationPill();
        });

        el.registerBtn.addEventListener('click', async () => {
          syncOfficialActivityToState(false);
          if (!parseOfficialActivity(state.activity)) {
            showMsg('error', 'Selecciona un tipo de actividad oficial y una fecha fin valida.');
            return;
          }
          state.durationMinutes = Math.max(1, Math.floor(Number(el.minutesInp.value || 0)));
          uiStateSave();
          renderDurationPill();
          try { await createWorklog(state.selectedIssueKey, state.activity, state.durationMinutes); }
          catch (e) { applyError(e, 'No se pudo registrar worklog.'); }
        });

        el.startBtn.addEventListener('click', timerStart);
        el.pauseBtn.addEventListener('click', timerPause);
        el.resetBtn.addEventListener('click', timerReset);
        el.applyTimerBtn.addEventListener('click', () => {
          applyTimerToMinutes();
          showMsg('info', `Duracion tomada del timer: ${TimeService.jiraDuration(state.durationMinutes)}.`);
        });

        el.applySugActBtn.addEventListener('click', () => {
          if (!state.suggestion) return;
          const suggested = String(state.suggestion.activityType || state.suggestion.activity || '').trim();
          state.activityType = OFFICIAL_ACTIVITY_TYPES.includes(suggested)
            ? suggested
            : inferOfficialActivityType(suggested);
          const suggestedDate = TimeService.toInputDate(state.suggestion.created || new Date());
          state.activityDueDate = isValidInputDate(suggestedDate)
            ? suggestedDate
            : TimeService.toInputDate(new Date());
          el.activityTypeSel.value = state.activityType;
          if (isValidInputDate(state.activityDueDate)) {
            el.activityDueInp.value = state.activityDueDate;
          }
          syncOfficialActivityToState(true);
        });

        el.applySugTimeBtn.addEventListener('click', () => {
          if (!state.suggestion) return;
          state.durationMinutes = state.suggestion.minutes;
          el.minutesInp.value = String(state.durationMinutes);
          uiStateSave();
          renderDurationPill();
        });
        el.registerSugBtn.addEventListener('click', async () => {
          if (!state.suggestion) return;
          if (!state.selectedIssueKey) {
            showMsg('error', 'Selecciona un ticket para registrar la sugerencia.');
            return;
          }
          const suggested = String(state.suggestion.activityType || state.suggestion.activity || '').trim();
          state.activityType = OFFICIAL_ACTIVITY_TYPES.includes(suggested)
            ? suggested
            : inferOfficialActivityType(suggested);
          const suggestedDate = TimeService.toInputDate(state.suggestion.created || new Date());
          state.activityDueDate = isValidInputDate(suggestedDate)
            ? suggestedDate
            : TimeService.toInputDate(new Date());
          state.activity = buildOfficialActivity(state.activityType, state.activityDueDate);
          state.durationMinutes = Math.max(1, Math.floor(Number(state.suggestion.minutes || 0)));
          el.activityTypeSel.value = state.activityType;
          el.activityDueInp.value = state.activityDueDate;
          el.activityInp.value = state.activity;
          el.minutesInp.value = String(state.durationMinutes);
          renderDurationPill();
          uiStateSave();
          try { await createWorklog(state.selectedIssueKey, state.activity, state.durationMinutes); }
          catch (e) { applyError(e, 'No se pudo registrar la sugerencia.'); }
        });

        if (FEATURES.dashboard) {
          el.refreshDashBtn.addEventListener('click', async () => {
            try { await refreshDashboard(); showMsg('ok', 'Dashboard actualizado.'); }
            catch (e) { applyError(e, 'No se pudo actualizar dashboard.'); }
          });
        }

        if (FEATURES.report) {
          el.genReportBtn.addEventListener('click', async () => {
            try { await generateReport(); }
            catch (e) { applyError(e, 'No se pudo generar reporte.'); }
          });
          el.exportReportBtn.addEventListener('click', exportReport);
        }

        el.commentsBox.addEventListener('click', (ev) => {
          const btn = ev.target;
          if (!btn || btn.dataset.act !== 'reg-from-comment') return;
          const commentId = btn.dataset.id;
          const comments = state.commentsByIssue[state.selectedIssueKey] || [];
          const c = comments.find((x) => String(x.id) === String(commentId));
          if (!c) return;
          const mins = Math.max(5, Math.min(480, TimeService.businessMinutesBetween(new Date(c.created), new Date())));
          state.regCtx = { issueKey: state.selectedIssueKey, commentId: String(c.id) };
          const inferredType = inferOfficialActivityType(commentText(c));
          const inferredDue = TimeService.toInputDate(c.created || new Date());
          el.regActInp.value = buildOfficialActivity(inferredType, inferredDue);
          el.regMinInp.value = String(mins);
          el.regModalMeta.textContent = `${state.selectedIssueKey} | ${TimeService.dtLabel(c.created)}`;
          el.regModal.classList.add('show');
        });

        el.regModalCancelBtn.addEventListener('click', () => { state.regCtx = null; el.regModal.classList.remove('show'); });
        el.regModalOkBtn.addEventListener('click', async () => {
          if (!state.regCtx) { el.regModal.classList.remove('show'); return; }
          const issueKey = state.regCtx.issueKey;
          const activity = String(el.regActInp.value || '').trim();
          const mins = Math.max(1, Math.floor(Number(el.regMinInp.value || 0)));
          if (!parseOfficialActivity(activity)) {
            showMsg('error', 'La actividad debe usar formato oficial: [Tipo de actividad] [DD/MM/AAAA].');
            return;
          }
          el.regModal.classList.remove('show');
          state.regCtx = null;
          try { await createWorklog(issueKey, activity, mins); }
          catch (e) { applyError(e, 'No se pudo registrar actividad desde comentario.'); }
        });

        el.worklogBody.addEventListener('click', async (ev) => {
          const btn = ev.target;
          if (!btn || !btn.dataset.act) return;
          const action = btn.dataset.act;
          const id = btn.dataset.id;
          const key = state.selectedIssueKey;
          if (!key || !id) return;
          const worklogs = state.worklogsByIssue[key] || [];
          const w = worklogs.find((x) => String(x.id) === String(id));
          if (!w) return;
          if (action === 'edit-worklog') {
            state.editCtx = { issueKey: key, id: String(id) };
            const d = new Date(w.started || w.created || new Date());
            el.editMeta.textContent = `${key} | Worklog ${id}`;
            el.editActInp.value = activityOf(w);
            el.editDateInp.value = TimeService.toInputDate(d);
            el.editTimeInp.value = TimeService.toInputTime(d);
            el.editMinInp.value = String(minutesOf(w));
            el.editModal.classList.add('show');
          }
          if (action === 'del-worklog') {
            if (!window.confirm(`Eliminar worklog ${id}?`)) return;
            try { await deleteWorklog(key, id); }
            catch (e) { applyError(e, 'No se pudo eliminar worklog.'); }
          }
        });

        el.editCancelBtn.addEventListener('click', () => { state.editCtx = null; el.editModal.classList.remove('show'); });
        el.editSaveBtn.addEventListener('click', async () => {
          if (!state.editCtx) { el.editModal.classList.remove('show'); return; }
          const act = String(el.editActInp.value || '').trim();
          const mins = Math.max(1, Math.floor(Number(el.editMinInp.value || 0)));
          const date = String(el.editDateInp.value || '');
          const time = String(el.editTimeInp.value || '08:30');
          const dt = new Date(`${date}T${time}:00`);
          if (!act || !date || Number.isNaN(dt.getTime()) || !mins) { showMsg('error', 'Completa actividad, fecha, hora y duracion.'); return; }
          const { issueKey, id } = state.editCtx;
          state.editCtx = null;
          el.editModal.classList.remove('show');
          try { await updateWorklog(issueKey, id, act, dt, mins); }
          catch (e) { applyError(e, 'No se pudo actualizar worklog.'); }
        });

        el.editDeleteBtn.addEventListener('click', async () => {
          if (!state.editCtx) return;
          const { issueKey, id } = state.editCtx;
          state.editCtx = null;
          el.editModal.classList.remove('show');
          if (!window.confirm(`Eliminar worklog ${id}?`)) return;
          try { await deleteWorklog(issueKey, id); }
          catch (e) { applyError(e, 'No se pudo eliminar worklog.'); }
        });

        el.compactBtn.addEventListener('click', () => {
          state.compact = !state.compact;
          uiStateSave();
          renderCompact();
        });
        el.floatExpandBtn.addEventListener('click', () => {
          state.compact = false;
          uiStateSave();
          renderCompact();
        });
        el.floatStartBtn.addEventListener('click', timerStart);
        el.floatPauseBtn.addEventListener('click', timerPause);
      }

      async function autoReconnect() {
        dbg('auto_reconnect_start');
        clearPopupWatcher();
        const defaultRedirectUri = deriveDefaultRedirectUri();
        if (!el.redirectUriInp.value && defaultRedirectUri) {
          el.redirectUriInp.value = defaultRedirectUri;
        }

        const cfg = StorageService.getConfig();
        if (cfg) {
          applyConfigToInputs(cfg);
        }

        const topHref = getTopLocationHref();
        if (topHref) {
          el.callbackUrlInp.value = topHref;
        }
        const params = parseUrlParams(topHref);
        if (params.code || params.error) {
          dbg('auto_reconnect_callback_in_url', { has_code: !!params.code, has_error: !!params.error });
          try {
            await processOAuthCallback(topHref, true);
            showMsg('ok', 'Sesion OAuth iniciada correctamente.');
            return;
          } catch (e) {
            resetConnectionState();
            renderTop();
            applyError(e, 'No se pudo completar OAuth al volver de Atlassian.');
            return;
          }
        }

        if (!cfg) {
          renderTop();
          return;
        }

        try {
          await connectWithStoredSession(cfg, false);
          showMsg('ok', 'Reconectado automaticamente.');
        } catch (e) {
          resetConnectionState();
          renderTop();
          if (e && e.kind === 'oauth' && e.status === 401) {
            showMsg('info', 'Conecta con OAuth para iniciar sesion en Jira.');
          } else {
            applyError(e, 'No se pudo reconectar automaticamente.');
          }
        }
      }

      function bootstrap() {
        dbg('bootstrap_start', {
          in_iframe: window.self !== window.top,
          top_href_available: !!getTopLocationHref()
        });
        cacheElements();
        bind();
        uiStateLoad();
        timerLoad();

        renderOfficialActivityControls();
        el.minutesInp.value = String(state.durationMinutes);
        renderActivitiesList();
        renderDurationPill();
        renderTop();
        renderIssueData();
        renderDashboard();
        renderReport();
        renderTimer();
        renderCompact();
        renderIdle();
        renderDebugLogs();

        window.setInterval(() => { renderTimer(); renderCompact(); renderIdle(); }, 1000);
        window.setInterval(renderIdle, 60000);

        autoReconnect();
      }

      bootstrap();
    })();
  </script>
</body>
</html>
