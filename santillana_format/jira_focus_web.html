<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Jira Focus Web</title>
  <style>
    :root {
      --bg: #edf2f8;
      --bg-soft: #f8fbff;
      --card: #ffffff;
      --line: #d5e2f1;
      --line-strong: #b9cde2;
      --text: #132538;
      --muted: #567089;
      --primary: #0d5ea8;
      --primary-dark: #0a4d89;
      --warn: #87500a;
      --danger: #ab2525;
      --ok: #157247;
      --shadow: 0 10px 28px rgba(14, 42, 74, 0.08);
    }
    * {
      box-sizing: border-box;
      min-width: 0;
    }
    html, body {
      max-width: 100%;
      overflow-x: hidden;
    }
    body {
      margin: 0;
      padding: 12px;
      font-family: "Trebuchet MS", "Gill Sans", "Verdana", sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 8% -20%, #ffffff 0, var(--bg-soft) 34%, transparent 58%),
        linear-gradient(180deg, #eef3f9 0%, var(--bg) 100%);
    }
    .app {
      display: grid;
      gap: 12px;
      width: 100%;
      max-width: 1320px;
      margin: 0 auto;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .topbar {
      border: 0;
      background: linear-gradient(120deg, #0e518f 0%, #1973ba 70%, #2f8bcb 100%);
      color: #ffffff;
    }
    .topbar h2 {
      color: #ffffff;
      letter-spacing: 0.2px;
    }
    .topbar .muted { color: rgba(235, 245, 255, 0.9); }
    .topbar .pill {
      color: #ffffff;
      border-color: rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.18);
      backdrop-filter: blur(3px);
    }
    .topbar .pill.ok {
      color: #ffffff;
      border-color: rgba(196, 255, 215, 0.65);
      background: rgba(55, 154, 95, 0.45);
    }
    .topbar .btn {
      color: #ffffff;
      border-color: rgba(255, 255, 255, 0.45);
      background: rgba(255, 255, 255, 0.16);
    }
    .topbar .btn:hover:not(:disabled) {
      border-color: rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.24);
    }
    .topbar .btn.danger {
      color: #ffffff;
      border-color: rgba(255, 209, 209, 0.75);
      background: rgba(173, 46, 46, 0.45);
    }
    .grid2 { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .grid3 { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
    .activity-config-grid {
      display: grid;
      grid-template-columns: minmax(220px, 2fr) minmax(220px, 2fr) minmax(170px, 1.2fr) minmax(120px, 1fr);
      gap: 10px;
      align-items: end;
      margin-top: 8px;
    }
    .board-head {
      padding-top: 10px;
      padding-bottom: 10px;
    }
    .board-ticket-picker {
      width: 100%;
      max-width: 100%;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.35fr) minmax(320px, 1fr);
      gap: 10px;
      align-items: start;
      margin-top: 10px;
    }
    .dashboard-grid > .card { min-height: 270px; }
    .panel-timeline {
      grid-column: 1;
      grid-row: 1;
      --tl-shell-border: #d8e5f3;
      --tl-shell-bg: linear-gradient(180deg, #fbfdff 0%, #f4f9ff 100%);
      --tl-stat-bg: #ffffff;
      --tl-stat-border: #d9e5f2;
      --tl-stat-value: #25425e;
      --tl-track-border: #d5e2f1;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(173, 200, 227, 0.16) 0, rgba(173, 200, 227, 0.16) 10%, rgba(255, 255, 255, 0.03) 10%, rgba(255, 255, 255, 0.03) 20%), linear-gradient(180deg, #f3f8fd 0%, #eaf2fb 100%);
      --tl-bar-bg: linear-gradient(90deg, #1d74c7, #4ab2dc);
      --tl-segment-border: rgba(10, 24, 39, 0.14);
      --tl-segment-active-ring: rgba(11, 80, 140, 0.35);
      --tl-total-color: #31506b;
      --tl-legend-bg: #f8fbff;
      --tl-legend-border: #d7e3f1;
      --tl-legend-color: #334f68;
      --tl-legend-hover-bg: #edf5ff;
      --tl-legend-hover-border: #9fc1e1;
      --tl-legend-active-bg: #e8f3ff;
      --tl-legend-active-border: #5d99cf;
      --tl-legend-active-color: #114d81;
      --tl-focus-border: #d8e5f3;
      --tl-focus-bg: linear-gradient(180deg, #fbfdff 0%, #f5f9ff 100%);
      --tl-focus-active-border: #7fb0dd;
      --tl-focus-active-ring: rgba(22, 111, 188, 0.12);
      --tl-gantt-row-bg: linear-gradient(180deg, #ffffff 0%, #f8fbff 100%);
      --tl-gantt-row-border: #d8e5f3;
      --tl-gantt-row-hover-border: #9fc1e1;
      --tl-gantt-row-hover-shadow: rgba(16, 52, 88, 0.08);
      --tl-gantt-row-active-bg: linear-gradient(180deg, #f4f9ff 0%, #ebf4ff 100%);
      --tl-gantt-row-active-border: #5d99cf;
      --tl-gantt-name: #264760;
      --tl-gantt-duration: #4b6279;
      --tl-picker-border: #d8e5f3;
      --tl-picker-bg: #f7fbff;
      --tl-picker-label: #31506b;
    }
    .panel-timeline.design-aurora {
      --tl-shell-border: #cbd7f8;
      --tl-shell-bg: linear-gradient(160deg, #f4f7ff 0%, #eefbff 58%, #fdf7ff 100%);
      --tl-stat-bg: #ffffff;
      --tl-stat-border: #d8e2fb;
      --tl-stat-value: #2f3f6b;
      --tl-track-border: #cdd8f5;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(157, 180, 247, 0.18) 0, rgba(157, 180, 247, 0.18) 10%, rgba(255, 255, 255, 0.03) 10%, rgba(255, 255, 255, 0.03) 20%), linear-gradient(180deg, #f4f7ff 0%, #ebf3ff 100%);
      --tl-bar-bg: linear-gradient(90deg, #4f71ff, #3fb9f3);
      --tl-segment-active-ring: rgba(79, 113, 255, 0.4);
      --tl-total-color: #2d4c75;
      --tl-legend-bg: #f4f8ff;
      --tl-legend-border: #d5e1f9;
      --tl-legend-color: #3a4f77;
      --tl-legend-hover-bg: #e9f2ff;
      --tl-legend-hover-border: #93b6ef;
      --tl-legend-active-bg: #e6efff;
      --tl-legend-active-border: #688ee0;
      --tl-legend-active-color: #244f9a;
      --tl-gantt-row-bg: linear-gradient(180deg, #ffffff 0%, #f5f9ff 100%);
      --tl-gantt-row-border: #d6e2f6;
      --tl-gantt-row-hover-border: #95b9ec;
      --tl-gantt-row-active-bg: linear-gradient(180deg, #edf4ff 0%, #e4efff 100%);
      --tl-gantt-row-active-border: #6289de;
    }
    .panel-timeline.design-midnight {
      --tl-shell-border: #24384e;
      --tl-shell-bg: linear-gradient(180deg, #152434 0%, #11202f 100%);
      --tl-stat-bg: #1a2a3d;
      --tl-stat-border: #2a4059;
      --tl-stat-value: #d7e8ff;
      --tl-track-border: #30465f;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(95, 132, 170, 0.2) 0, rgba(95, 132, 170, 0.2) 10%, rgba(17, 32, 47, 0.04) 10%, rgba(17, 32, 47, 0.04) 20%), linear-gradient(180deg, #24384f 0%, #1a2e44 100%);
      --tl-bar-bg: linear-gradient(90deg, #2d96f0, #5de0c5);
      --tl-segment-border: rgba(194, 222, 255, 0.32);
      --tl-segment-active-ring: rgba(93, 224, 197, 0.52);
      --tl-total-color: #c8ddf5;
      --tl-legend-bg: #1b2d41;
      --tl-legend-border: #2a435e;
      --tl-legend-color: #c8dcf3;
      --tl-legend-hover-bg: #213850;
      --tl-legend-hover-border: #3e658a;
      --tl-legend-active-bg: #244365;
      --tl-legend-active-border: #66b4ff;
      --tl-legend-active-color: #dff2ff;
      --tl-focus-border: #2a435e;
      --tl-focus-bg: linear-gradient(180deg, #16283b 0%, #132638 100%);
      --tl-focus-active-border: #4a82b6;
      --tl-focus-active-ring: rgba(76, 147, 212, 0.26);
      --tl-gantt-row-bg: linear-gradient(180deg, #16283b 0%, #132637 100%);
      --tl-gantt-row-border: #2b425d;
      --tl-gantt-row-hover-border: #4572a1;
      --tl-gantt-row-hover-shadow: rgba(0, 0, 0, 0.25);
      --tl-gantt-row-active-bg: linear-gradient(180deg, #203850 0%, #1b3248 100%);
      --tl-gantt-row-active-border: #57a6ee;
      --tl-gantt-name: #d7e9ff;
      --tl-gantt-duration: #b6cce6;
      --tl-picker-border: #2a435e;
      --tl-picker-bg: #16283b;
      --tl-picker-label: #c8dcf3;
    }
    .panel-timeline.design-emerald {
      --tl-shell-border: #b7decf;
      --tl-shell-bg: linear-gradient(180deg, #f3fcf8 0%, #ecfaf4 100%);
      --tl-stat-border: #c5e7da;
      --tl-stat-value: #1f5c52;
      --tl-track-border: #b9dfcf;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(159, 214, 194, 0.2) 0, rgba(159, 214, 194, 0.2) 10%, rgba(255, 255, 255, 0.03) 10%, rgba(255, 255, 255, 0.03) 20%), linear-gradient(180deg, #eefaf4 0%, #e6f6ef 100%);
      --tl-bar-bg: linear-gradient(90deg, #1da574, #4fc989);
      --tl-segment-active-ring: rgba(32, 152, 111, 0.42);
      --tl-total-color: #28695f;
      --tl-legend-bg: #f2fcf7;
      --tl-legend-border: #c6e8d9;
      --tl-legend-color: #2b665b;
      --tl-legend-hover-bg: #e9f8f1;
      --tl-legend-hover-border: #87c7ad;
      --tl-legend-active-bg: #e0f4ea;
      --tl-legend-active-border: #45a47e;
      --tl-legend-active-color: #1c6d4e;
      --tl-focus-border: #c5e7da;
      --tl-focus-bg: linear-gradient(180deg, #f5fdf9 0%, #eefaf4 100%);
      --tl-focus-active-border: #63b997;
      --tl-focus-active-ring: rgba(40, 161, 122, 0.2);
      --tl-gantt-row-border: #c8e9dc;
      --tl-gantt-row-hover-border: #7fbeaa;
      --tl-gantt-row-active-bg: linear-gradient(180deg, #ebf9f2 0%, #dff2e9 100%);
      --tl-gantt-row-active-border: #47a481;
      --tl-gantt-name: #265f56;
      --tl-gantt-duration: #3a6c62;
      --tl-picker-border: #c5e7da;
      --tl-picker-bg: #f3fcf8;
      --tl-picker-label: #2a655a;
    }
    .panel-timeline.design-amber {
      --tl-shell-border: #ecd5b0;
      --tl-shell-bg: linear-gradient(180deg, #fffbf2 0%, #fff7e9 100%);
      --tl-stat-border: #efd9b8;
      --tl-stat-value: #6a4c16;
      --tl-track-border: #e9d0a7;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(241, 205, 149, 0.24) 0, rgba(241, 205, 149, 0.24) 10%, rgba(255, 255, 255, 0.03) 10%, rgba(255, 255, 255, 0.03) 20%), linear-gradient(180deg, #fff8eb 0%, #fff1dc 100%);
      --tl-bar-bg: linear-gradient(90deg, #e89b1f, #ffb84e);
      --tl-segment-active-ring: rgba(217, 133, 10, 0.36);
      --tl-total-color: #7b5719;
      --tl-legend-bg: #fff8ec;
      --tl-legend-border: #efd9b7;
      --tl-legend-color: #78561a;
      --tl-legend-hover-bg: #fff2dc;
      --tl-legend-hover-border: #d8aa63;
      --tl-legend-active-bg: #ffeed2;
      --tl-legend-active-border: #ca8a22;
      --tl-legend-active-color: #7b4d00;
      --tl-focus-border: #efd9b7;
      --tl-focus-bg: linear-gradient(180deg, #fffbf3 0%, #fff7e9 100%);
      --tl-focus-active-border: #d7a156;
      --tl-focus-active-ring: rgba(214, 152, 58, 0.22);
      --tl-gantt-row-border: #efd8b5;
      --tl-gantt-row-hover-border: #d7a35d;
      --tl-gantt-row-active-bg: linear-gradient(180deg, #fff4df 0%, #ffeecf 100%);
      --tl-gantt-row-active-border: #c88313;
      --tl-gantt-name: #6d4d1a;
      --tl-gantt-duration: #7d623a;
      --tl-picker-border: #edd8b4;
      --tl-picker-bg: #fff8ec;
      --tl-picker-label: #7a5924;
    }
    .panel-timeline.design-rose {
      --tl-shell-border: #eccfdb;
      --tl-shell-bg: linear-gradient(180deg, #fff8fb 0%, #fff2f8 100%);
      --tl-stat-border: #efd7e1;
      --tl-stat-value: #6b3c53;
      --tl-track-border: #e8cfdd;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(235, 187, 210, 0.22) 0, rgba(235, 187, 210, 0.22) 10%, rgba(255, 255, 255, 0.03) 10%, rgba(255, 255, 255, 0.03) 20%), linear-gradient(180deg, #fff5fb 0%, #ffebf4 100%);
      --tl-bar-bg: linear-gradient(90deg, #ce4c85, #f08db7);
      --tl-segment-active-ring: rgba(189, 58, 116, 0.36);
      --tl-total-color: #75445b;
      --tl-legend-bg: #fff4f9;
      --tl-legend-border: #eed5e2;
      --tl-legend-color: #6f4358;
      --tl-legend-hover-bg: #ffeaf4;
      --tl-legend-hover-border: #d9a6bf;
      --tl-legend-active-bg: #ffe2f0;
      --tl-legend-active-border: #c76a94;
      --tl-legend-active-color: #8f325f;
      --tl-focus-border: #eed5e2;
      --tl-focus-bg: linear-gradient(180deg, #fff9fc 0%, #fff2f8 100%);
      --tl-focus-active-border: #cf86aa;
      --tl-focus-active-ring: rgba(201, 110, 156, 0.2);
      --tl-gantt-row-border: #eed6e2;
      --tl-gantt-row-hover-border: #cf8cab;
      --tl-gantt-row-active-bg: linear-gradient(180deg, #fff0f7 0%, #ffe5f1 100%);
      --tl-gantt-row-active-border: #be5f8a;
      --tl-gantt-name: #6a3e55;
      --tl-gantt-duration: #7a5a6d;
      --tl-picker-border: #edd4e1;
      --tl-picker-bg: #fff5fa;
      --tl-picker-label: #764f64;
    }
    .panel-timeline.design-minimal {
      --tl-shell-border: #d7dde4;
      --tl-shell-bg: linear-gradient(180deg, #ffffff 0%, #f7f8fa 100%);
      --tl-stat-border: #d9dfe6;
      --tl-stat-value: #37424f;
      --tl-track-border: #d5dce4;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(184, 194, 206, 0.2) 0, rgba(184, 194, 206, 0.2) 10%, rgba(255, 255, 255, 0.03) 10%, rgba(255, 255, 255, 0.03) 20%), linear-gradient(180deg, #f7f9fb 0%, #edf1f5 100%);
      --tl-bar-bg: linear-gradient(90deg, #4d6078, #7c8fa5);
      --tl-segment-active-ring: rgba(90, 108, 132, 0.35);
      --tl-total-color: #4a5563;
      --tl-legend-bg: #f7f9fb;
      --tl-legend-border: #d9dfe6;
      --tl-legend-color: #4a5768;
      --tl-legend-hover-bg: #eef2f6;
      --tl-legend-hover-border: #b2bfcc;
      --tl-legend-active-bg: #e8edf3;
      --tl-legend-active-border: #8295a8;
      --tl-legend-active-color: #344454;
      --tl-focus-border: #d9dfe6;
      --tl-focus-bg: linear-gradient(180deg, #fcfdff 0%, #f6f8fb 100%);
      --tl-focus-active-border: #8ca0b4;
      --tl-focus-active-ring: rgba(102, 122, 145, 0.2);
      --tl-gantt-row-border: #dbe1e8;
      --tl-gantt-row-hover-border: #b3bfcb;
      --tl-gantt-row-active-bg: linear-gradient(180deg, #f2f5f9 0%, #e9edf2 100%);
      --tl-gantt-row-active-border: #7f90a4;
      --tl-gantt-name: #3e4a57;
      --tl-gantt-duration: #5a6775;
      --tl-picker-border: #d8dfe7;
      --tl-picker-bg: #f8fafc;
      --tl-picker-label: #4d5a6a;
    }
    .panel-timeline.design-neon {
      --tl-shell-border: #283262;
      --tl-shell-bg: linear-gradient(180deg, #0f1330 0%, #121a3d 100%);
      --tl-stat-bg: #151c42;
      --tl-stat-border: #2a3b73;
      --tl-stat-value: #ddf6ff;
      --tl-track-border: #2e3f78;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(77, 113, 214, 0.24) 0, rgba(77, 113, 214, 0.24) 10%, rgba(15, 19, 48, 0.04) 10%, rgba(15, 19, 48, 0.04) 20%), linear-gradient(180deg, #1a2557 0%, #16224d 100%);
      --tl-bar-bg: linear-gradient(90deg, #3ef6ff, #7d7dff);
      --tl-segment-border: rgba(191, 236, 255, 0.36);
      --tl-segment-active-ring: rgba(89, 236, 255, 0.56);
      --tl-total-color: #d7eeff;
      --tl-legend-bg: #16204a;
      --tl-legend-border: #304885;
      --tl-legend-color: #d4e6ff;
      --tl-legend-hover-bg: #1c2a60;
      --tl-legend-hover-border: #4670c9;
      --tl-legend-active-bg: #20356d;
      --tl-legend-active-border: #5fb3ff;
      --tl-legend-active-color: #e4fbff;
      --tl-focus-border: #2d4481;
      --tl-focus-bg: linear-gradient(180deg, #141c45 0%, #121a3f 100%);
      --tl-focus-active-border: #5f90f0;
      --tl-focus-active-ring: rgba(88, 167, 255, 0.3);
      --tl-gantt-row-bg: linear-gradient(180deg, #131c45 0%, #121a40 100%);
      --tl-gantt-row-border: #304987;
      --tl-gantt-row-hover-border: #4f73ca;
      --tl-gantt-row-hover-shadow: rgba(0, 0, 0, 0.32);
      --tl-gantt-row-active-bg: linear-gradient(180deg, #1b2d60 0%, #172956 100%);
      --tl-gantt-row-active-border: #63b0ff;
      --tl-gantt-name: #e1f4ff;
      --tl-gantt-duration: #bad7f5;
      --tl-picker-border: #2f4784;
      --tl-picker-bg: #141c45;
      --tl-picker-label: #cbe3ff;
    }
    .panel-timeline.design-paper {
      --tl-shell-border: #d8cdbf;
      --tl-shell-bg: linear-gradient(180deg, #fffdf7 0%, #fcf7ed 100%);
      --tl-stat-border: #ded1c1;
      --tl-stat-value: #5b4935;
      --tl-track-border: #d8c9b6;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(220, 202, 175, 0.25) 0, rgba(220, 202, 175, 0.25) 10%, rgba(255, 255, 255, 0.03) 10%, rgba(255, 255, 255, 0.03) 20%), linear-gradient(180deg, #fdf8ee 0%, #f8f0e1 100%);
      --tl-bar-bg: linear-gradient(90deg, #8a6c45, #b38c5f);
      --tl-segment-active-ring: rgba(130, 97, 55, 0.36);
      --tl-total-color: #6a5237;
      --tl-legend-bg: #fdf8ef;
      --tl-legend-border: #dfd0bd;
      --tl-legend-color: #655038;
      --tl-legend-hover-bg: #f7ecdc;
      --tl-legend-hover-border: #c6aa85;
      --tl-legend-active-bg: #f1e2ca;
      --tl-legend-active-border: #aa8251;
      --tl-legend-active-color: #5f4423;
      --tl-focus-border: #ded1c1;
      --tl-focus-bg: linear-gradient(180deg, #fffcf6 0%, #faf4e9 100%);
      --tl-focus-active-border: #ba9b74;
      --tl-focus-active-ring: rgba(160, 126, 84, 0.22);
      --tl-gantt-row-border: #e0d2bf;
      --tl-gantt-row-hover-border: #c7aa84;
      --tl-gantt-row-active-bg: linear-gradient(180deg, #f8efe0 0%, #f1e4cf 100%);
      --tl-gantt-row-active-border: #a57c46;
      --tl-gantt-name: #5f4932;
      --tl-gantt-duration: #725a3f;
      --tl-picker-border: #dfd0bd;
      --tl-picker-bg: #fdf8ef;
      --tl-picker-label: #69523a;
    }
    .panel-timeline.design-sunset {
      --tl-shell-border: #efcbb3;
      --tl-shell-bg: linear-gradient(180deg, #fff8f3 0%, #fff1e9 100%);
      --tl-stat-border: #f0d3be;
      --tl-stat-value: #7c3f2f;
      --tl-track-border: #ebc8ad;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(245, 184, 151, 0.26) 0, rgba(245, 184, 151, 0.26) 10%, rgba(255, 255, 255, 0.03) 10%, rgba(255, 255, 255, 0.03) 20%), linear-gradient(180deg, #fff3e8 0%, #ffe8d7 100%);
      --tl-bar-bg: linear-gradient(90deg, #f26b3f, #f4ab53);
      --tl-segment-active-ring: rgba(224, 93, 41, 0.36);
      --tl-total-color: #8a4a36;
      --tl-legend-bg: #fff2e9;
      --tl-legend-border: #efd2bf;
      --tl-legend-color: #844d39;
      --tl-legend-hover-bg: #ffe8db;
      --tl-legend-hover-border: #e1a880;
      --tl-legend-active-bg: #ffdfcb;
      --tl-legend-active-border: #cf7443;
      --tl-legend-active-color: #8a401f;
      --tl-focus-border: #efd2bf;
      --tl-focus-bg: linear-gradient(180deg, #fff9f4 0%, #fff1e8 100%);
      --tl-focus-active-border: #d28f67;
      --tl-focus-active-ring: rgba(213, 115, 68, 0.22);
      --tl-gantt-row-border: #efd2bf;
      --tl-gantt-row-hover-border: #dc9871;
      --tl-gantt-row-active-bg: linear-gradient(180deg, #ffeede 0%, #ffe2cf 100%);
      --tl-gantt-row-active-border: #c96f3d;
      --tl-gantt-name: #7b4836;
      --tl-gantt-duration: #916252;
      --tl-picker-border: #eed0bc;
      --tl-picker-bg: #fff3ea;
      --tl-picker-label: #844f3c;
    }
    .panel-timeline.design-contrast {
      --tl-shell-border: #334657;
      --tl-shell-bg: linear-gradient(180deg, #ffffff 0%, #f4f8fc 100%);
      --tl-stat-border: #334657;
      --tl-stat-value: #102334;
      --tl-track-border: #334657;
      --tl-track-bg: repeating-linear-gradient(90deg, rgba(51, 70, 87, 0.24) 0, rgba(51, 70, 87, 0.24) 10%, rgba(255, 255, 255, 0.03) 10%, rgba(255, 255, 255, 0.03) 20%), linear-gradient(180deg, #e8f0f8 0%, #d9e4ef 100%);
      --tl-bar-bg: linear-gradient(90deg, #003c75, #0090ff);
      --tl-segment-border: rgba(7, 20, 32, 0.4);
      --tl-segment-active-ring: rgba(0, 113, 209, 0.45);
      --tl-total-color: #143146;
      --tl-legend-bg: #ffffff;
      --tl-legend-border: #334657;
      --tl-legend-color: #16364f;
      --tl-legend-hover-bg: #ecf5ff;
      --tl-legend-hover-border: #2a628f;
      --tl-legend-active-bg: #deeeff;
      --tl-legend-active-border: #005697;
      --tl-legend-active-color: #003b69;
      --tl-focus-border: #334657;
      --tl-focus-bg: linear-gradient(180deg, #ffffff 0%, #f5f9fd 100%);
      --tl-focus-active-border: #2f7fbd;
      --tl-focus-active-ring: rgba(0, 98, 181, 0.2);
      --tl-gantt-row-border: #334657;
      --tl-gantt-row-hover-border: #276ba0;
      --tl-gantt-row-active-bg: linear-gradient(180deg, #e8f3ff 0%, #d8ebff 100%);
      --tl-gantt-row-active-border: #005ea3;
      --tl-gantt-name: #16324a;
      --tl-gantt-duration: #30506a;
      --tl-picker-border: #334657;
      --tl-picker-bg: #f4f8fc;
      --tl-picker-label: #18374f;
    }
    .panel-comments { grid-column: 1; grid-row: 2; }
    .panel-worklogs {
      grid-column: 2;
      grid-row: 1 / span 2;
      display: flex;
      flex-direction: column;
      align-self: start;
    }
    .dashboard-grid > .card.panel-worklogs {
      min-height: 0;
    }
    .panel-comments .comments { max-height: 430px; }
    .panel-worklogs .tbl-wrap {
      flex: 1 1 auto;
      max-height: min(56vh, 620px);
      min-height: 0;
    }
    .edit-inline {
      margin-top: 10px;
      border: 1px solid #d9e5f2;
      border-radius: 10px;
      padding: 10px;
      background: #f8fbff;
    }
    .edit-inline-title {
      font-size: 14px;
      font-weight: 700;
      color: #274760;
      margin-bottom: 4px;
    }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    h2, h3, h4 { margin: 0 0 8px 0; }
    h3 { font-size: 17px; letter-spacing: 0.15px; }
    .muted { color: var(--muted); font-size: 12px; }
    .pill {
      display: inline-flex;
      align-items: center;
      max-width: 100%;
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 5px 11px;
      font-size: 12px;
      color: var(--muted);
      background: #fff;
      white-space: normal;
      overflow-wrap: anywhere;
    }
    .pill.ok { color: var(--ok); border-color: #a6d8bb; background: #edfbf3; }
    .pill.warn { color: var(--warn); border-color: #efcd8f; background: #fff7e8; }
    .btn {
      border: 1px solid #c4d3e3;
      border-radius: 9px;
      background: linear-gradient(180deg, #ffffff 0%, #f4f8fc 100%);
      color: var(--text);
      padding: 8px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      border-color: var(--line-strong);
      box-shadow: 0 4px 10px rgba(20, 43, 70, 0.08);
    }
    .btn:disabled { opacity: .55; cursor: not-allowed; }
    .btn.primary {
      background: linear-gradient(180deg, #1472bf 0%, var(--primary) 100%);
      border-color: var(--primary-dark);
      color: #fff;
    }
    .btn.warn { background: #fff7e8; border-color: #efcd8f; color: var(--warn); }
    .btn.danger { background: #fff1f1; border-color: #e6b2b2; color: var(--danger); }
    .inp, .sel, .txt {
      width: 100%;
      border: 1px solid #c5d4e6;
      border-radius: 9px;
      padding: 8px 10px;
      font-size: 13px;
      background: #fff;
      color: var(--text);
    }
    .inp[readonly] {
      background: #f4f8fd;
      color: #2b445a;
      border-color: #c6d7e8;
    }
    .inp:focus, .sel:focus, .txt:focus {
      outline: none;
      border-color: #75a8d5;
      box-shadow: 0 0 0 3px rgba(62, 133, 196, 0.14);
    }
    .txt { min-height: 90px; resize: vertical; }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 5px; }
    .msg { display: none; padding: 9px 10px; border-radius: 9px; border: 1px solid transparent; font-size: 13px; }
    .msg.show { display: block; }
    .msg.error { background: #ffeaea; border-color: #edb8b8; color: var(--danger); }
    .msg.ok { background: #ebfaf1; border-color: #b7dfc8; color: var(--ok); }
    .msg.info { background: #eaf4ff; border-color: #bad6f6; color: #23527d; }
    .empty {
      border: 1px dashed #c8d6e7;
      border-radius: 10px;
      padding: 10px;
      font-size: 13px;
      color: var(--muted);
      background: linear-gradient(180deg, #fbfdff 0%, #f4f9ff 100%);
    }
    .timer { font-size: 30px; font-weight: 700; font-variant-numeric: tabular-nums; margin: 0 0 4px 0; }
    .tbl-wrap {
      border: 1px solid var(--line);
      border-radius: 10px;
      overflow-y: auto;
      overflow-x: hidden;
      max-height: 360px;
      background: #fff;
    }
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      min-width: 0;
      table-layout: fixed;
      font-size: 12px;
    }
    th, td {
      border-bottom: 1px solid #e8eff7;
      padding: 8px;
      text-align: left;
      vertical-align: top;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    th {
      position: sticky;
      top: 0;
      z-index: 1;
      background: #f3f8ff;
    }
    .comments { display: grid; gap: 8px; max-height: 360px; overflow: auto; }
    .comment { border: 1px solid var(--line); border-radius: 9px; padding: 8px; background: #fff; }
    .comment.mine { background: #f7fbff; border: 2px solid #2f8bcb; }
    .comment.selected {
      border-color: #5d99cf;
      box-shadow: 0 0 0 2px rgba(22, 111, 188, 0.14);
      background: #eef6ff;
    }
    .meta { display: flex; justify-content: space-between; gap: 8px; color: var(--muted); font-size: 11px; margin-bottom: 4px; flex-wrap: wrap; }
    .body { white-space: pre-wrap; font-size: 13px; overflow-wrap: anywhere; }
    .track {
      height: 12px;
      border-radius: 999px;
      background: var(--tl-track-bg);
      border: 1px solid var(--tl-track-border);
      position: relative;
      overflow: hidden;
    }
    .bar {
      position: absolute;
      top: 1px;
      bottom: 1px;
      border-radius: 999px;
      background: var(--tl-bar-bg);
      box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.08);
    }
    .activity-focus {
      border: 1px solid var(--tl-focus-border, #d8e5f3);
      border-radius: 11px;
      padding: 9px;
      background: var(--tl-focus-bg, linear-gradient(180deg, #fbfdff 0%, #f5f9ff 100%));
      margin-bottom: 10px;
      transition: border-color .15s ease, box-shadow .15s ease;
    }
    .activity-focus.active {
      border-color: var(--tl-focus-active-border, #7fb0dd);
      box-shadow: 0 0 0 3px var(--tl-focus-active-ring, rgba(22, 111, 188, 0.12));
    }
    .activity-focus .muted {
      font-size: 11px;
      margin-top: 5px;
    }
    .timeline-shell {
      border: 1px solid var(--tl-shell-border);
      border-radius: 12px;
      padding: 10px;
      background: var(--tl-shell-bg);
    }
    .timeline-head {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 10px;
    }
    .timeline-stat {
      background: var(--tl-stat-bg);
      border: 1px solid var(--tl-stat-border);
      border-radius: 10px;
      padding: 7px 8px;
      min-height: 54px;
    }
    .timeline-stat-label {
      font-size: 10px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .06em;
      margin-bottom: 2px;
    }
    .timeline-stat-value {
      font-size: 12px;
      color: var(--tl-stat-value);
      font-weight: 700;
      overflow-wrap: anywhere;
    }
    .timeline-ticket-list {
      display: grid;
      gap: 8px;
      margin-top: 4px;
    }
    .timeline-ticket-row {
      display: grid;
      grid-template-columns: minmax(180px, 1.45fr) minmax(0, 3fr) 90px;
      gap: 9px;
      align-items: center;
    }
    .timeline-ticket-label {
      font-size: 12px;
      color: var(--text);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 700;
    }
    .timeline-ticket-track {
      position: relative;
      height: 24px;
      border: 1px solid var(--tl-track-border);
      border-radius: 999px;
      background: var(--tl-track-bg);
      overflow: hidden;
    }
    .timeline-ticket-segment {
      position: absolute;
      top: 3px;
      bottom: 3px;
      border-radius: 999px;
      min-width: 2px;
      opacity: 0.86;
      border: 1px solid var(--tl-segment-border);
      cursor: pointer;
      transition: opacity .15s ease, transform .15s ease, box-shadow .15s ease;
    }
    .timeline-ticket-segment:hover {
      opacity: 1;
      transform: scaleY(1.05);
    }
    .timeline-ticket-segment.active {
      opacity: 1;
      box-shadow: 0 0 0 2px var(--tl-segment-active-ring);
      z-index: 2;
    }
    .timeline-ticket-total {
      font-size: 12px;
      color: var(--tl-total-color);
      text-align: right;
      white-space: nowrap;
      font-weight: 700;
    }
    .activity-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    .activity-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid var(--tl-legend-border);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      color: var(--tl-legend-color);
      background: var(--tl-legend-bg);
      max-width: 100%;
      cursor: pointer;
      transition: border-color .15s ease, background .15s ease, transform .15s ease;
    }
    .activity-legend-item:hover {
      transform: translateY(-1px);
      border-color: var(--tl-legend-hover-border);
      background: var(--tl-legend-hover-bg);
    }
    .activity-legend-item.active {
      border-color: var(--tl-legend-active-border);
      background: var(--tl-legend-active-bg);
      color: var(--tl-legend-active-color);
      font-weight: 700;
      box-shadow: 0 0 0 2px rgba(22, 111, 188, 0.12);
    }
    .activity-legend-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      flex: 0 0 auto;
    }
    .gantt-list {
      display: grid;
      gap: 7px;
    }
    .gantt-row {
      display: grid;
      grid-template-columns: minmax(160px, 1.6fr) minmax(0, 2fr) 90px;
      gap: 9px;
      align-items: center;
      font-size: 12px;
      border: 1px solid var(--tl-gantt-row-border);
      border-radius: 10px;
      padding: 7px 8px;
      background: var(--tl-gantt-row-bg);
      cursor: pointer;
      transition: border-color .15s ease, box-shadow .15s ease, transform .15s ease;
    }
    .gantt-row:hover {
      border-color: var(--tl-gantt-row-hover-border);
      box-shadow: 0 3px 9px var(--tl-gantt-row-hover-shadow);
      transform: translateY(-1px);
    }
    .gantt-row.active {
      border-color: var(--tl-gantt-row-active-border);
      box-shadow: 0 0 0 2px rgba(22, 111, 188, 0.14);
      background: var(--tl-gantt-row-active-bg);
    }
    .gantt-name {
      font-weight: 700;
      color: var(--tl-gantt-name);
      overflow-wrap: anywhere;
    }
    .gantt-duration {
      text-align: right;
      color: var(--tl-gantt-duration);
      font-weight: 700;
    }
    .chart-headline {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 10px;
    }
    .chart-kpi {
      border: 1px solid #d8e5f3;
      border-radius: 10px;
      padding: 7px 8px;
      background: #fff;
    }
    .chart-kpi .k {
      font-size: 10px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .06em;
      margin-bottom: 2px;
    }
    .chart-kpi .v {
      font-size: 12px;
      font-weight: 700;
      color: #264760;
      overflow-wrap: anywhere;
    }
    .chart-stack {
      display: grid;
      gap: 8px;
    }
    .chart-stack-row {
      display: grid;
      grid-template-columns: minmax(180px, 1.8fr) minmax(0, 2fr) 80px;
      gap: 8px;
      align-items: center;
      border: 1px solid #d9e5f2;
      border-radius: 9px;
      padding: 7px 8px;
      background: #fff;
      cursor: pointer;
    }
    .chart-stack-row:hover {
      border-color: #8fb6dc;
      background: #f6fbff;
    }
    .chart-stack-row.active {
      border-color: #5b95ca;
      box-shadow: 0 0 0 2px rgba(22, 111, 188, 0.14);
      background: #eef6ff;
    }
    .chart-stack-name {
      font-size: 12px;
      font-weight: 700;
      color: #2a4861;
      overflow-wrap: anywhere;
    }
    .chart-stack-val {
      text-align: right;
      font-size: 11px;
      color: #48627a;
      font-weight: 700;
    }
    .chart-cards {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }
    .chart-card {
      border: 1px solid #d9e5f2;
      border-radius: 10px;
      padding: 8px;
      background: #fff;
      cursor: pointer;
    }
    .chart-card.active {
      border-color: #5b95ca;
      box-shadow: 0 0 0 2px rgba(22, 111, 188, 0.14);
      background: #eef6ff;
    }
    .chart-card-title {
      font-size: 12px;
      font-weight: 700;
      color: #2a4861;
      margin-bottom: 6px;
      overflow-wrap: anywhere;
    }
    .chart-card-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: #4c6680;
      margin-top: 6px;
      gap: 8px;
    }
    .chart-donut-wrap {
      display: grid;
      grid-template-columns: 220px 1fr;
      gap: 10px;
      align-items: center;
    }
    .chart-donut {
      width: 210px;
      height: 210px;
      border-radius: 50%;
      margin: 0 auto;
      position: relative;
      border: 1px solid #d6e3f1;
    }
    .chart-donut-center {
      position: absolute;
      inset: 23%;
      border-radius: 50%;
      background: #fff;
      border: 1px solid #dfe9f4;
      display: grid;
      place-items: center;
      text-align: center;
      padding: 8px;
    }
    .chart-donut-center .big {
      font-size: 16px;
      font-weight: 700;
      color: #25425e;
      line-height: 1.2;
    }
    .chart-donut-center .small {
      font-size: 11px;
      color: var(--muted);
    }
    .chart-week-list,
    .chart-day-list,
    .chart-steps {
      display: grid;
      gap: 7px;
    }
    .chart-week-row,
    .chart-day-row,
    .chart-step-row {
      border: 1px solid #d9e5f2;
      border-radius: 9px;
      padding: 7px 8px;
      background: #fff;
      display: grid;
      gap: 6px;
    }
    .chart-step-row.active {
      border-color: #5b95ca;
      box-shadow: 0 0 0 2px rgba(22, 111, 188, 0.14);
      background: #eef6ff;
    }
    .chart-row-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #2d4b64;
      font-weight: 700;
      flex-wrap: wrap;
    }
    .chart-row-sub {
      font-size: 11px;
      color: #587088;
      overflow-wrap: anywhere;
    }
    .chart-matrix-wrap {
      border: 1px solid #d8e5f3;
      border-radius: 10px;
      overflow: auto;
      background: #fff;
      max-height: 310px;
    }
    .chart-matrix {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: 11px;
      min-width: 620px;
    }
    .chart-matrix th,
    .chart-matrix td {
      border-bottom: 1px solid #e6eef8;
      border-right: 1px solid #edf3fb;
      padding: 6px;
      text-align: center;
      vertical-align: middle;
    }
    .chart-matrix th:first-child,
    .chart-matrix td:first-child {
      text-align: left;
      min-width: 180px;
      position: sticky;
      left: 0;
      z-index: 1;
      background: #f9fcff;
    }
    .chart-matrix td.activity-cell {
      cursor: pointer;
      font-weight: 700;
      color: #274760;
    }
    .chart-matrix td.activity-cell.active {
      box-shadow: inset 0 0 0 2px rgba(22, 111, 188, 0.2);
      background: #edf6ff;
    }
    .chart-mini-table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: 12px;
      background: #fff;
      border: 1px solid #d8e5f3;
      border-radius: 10px;
      overflow: hidden;
    }
    .chart-mini-table th,
    .chart-mini-table td {
      padding: 7px 8px;
      border-bottom: 1px solid #e8eff7;
      text-align: left;
      vertical-align: middle;
    }
    .chart-mini-table th {
      background: #f4f9ff;
      color: #31506b;
      font-size: 11px;
    }
    .chart-mini-table tr.active td {
      background: #eef6ff;
    }
    .chart-clickable {
      cursor: pointer;
      color: #225f97;
      font-weight: 700;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 2px;
    }
    .chart-note {
      border: 1px dashed #c9d8e9;
      border-radius: 9px;
      padding: 8px;
      font-size: 12px;
      color: #5a7188;
      background: #f9fcff;
    }
    .timeline-continuous {
      border: 1px solid #d8e5f3;
      border-radius: 10px;
      padding: 10px;
      background: #fbfdff;
    }
    .timeline-meta {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 10px;
    }
    .timeline-meta-item {
      border: 1px solid #dae7f4;
      border-radius: 9px;
      padding: 6px 8px;
      background: #fff;
    }
    .timeline-meta-item .k {
      font-size: 10px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .05em;
      margin-bottom: 2px;
    }
    .timeline-meta-item .v {
      font-size: 12px;
      font-weight: 700;
      color: #264760;
      overflow-wrap: anywhere;
    }
    .timeline-lane-list {
      display: grid;
      gap: 8px;
    }
    .timeline-lane {
      display: grid;
      grid-template-columns: minmax(210px, 1.6fr) minmax(0, 4fr);
      gap: 8px;
      align-items: center;
    }
    .timeline-lane.comments-only {
      grid-template-columns: 1fr;
    }
    .timeline-lane-label {
      font-size: 12px;
      color: #2a4861;
      font-weight: 700;
      overflow-wrap: anywhere;
    }
    .timeline-lane-track {
      position: relative;
      height: 30px;
      border: 1px solid #d4e2f1;
      border-radius: 999px;
      background:
        repeating-linear-gradient(90deg, rgba(178, 201, 227, 0.18) 0, rgba(178, 201, 227, 0.18) 10%, rgba(255, 255, 255, 0.02) 10%, rgba(255, 255, 255, 0.02) 20%),
        linear-gradient(180deg, #f4f8fd 0%, #eaf2fb 100%);
      overflow: hidden;
    }
    .timeline-worklog-bar {
      position: absolute;
      top: 4px;
      bottom: 4px;
      border-radius: 999px;
      min-width: 3px;
      border: 1px solid rgba(9, 24, 39, 0.18);
      cursor: pointer;
      opacity: 0.88;
      transition: transform .12s ease, opacity .12s ease, box-shadow .12s ease;
    }
    .timeline-worklog-bar:hover {
      opacity: 1;
      transform: scaleY(1.06);
    }
    .timeline-worklog-bar.active {
      opacity: 1;
      box-shadow: 0 0 0 2px rgba(11, 80, 140, 0.38);
      z-index: 2;
    }
    .timeline-worklog-bar.unlinked {
      border-style: dashed;
      border-color: #ad6d3e;
    }
    .timeline-comment-dot {
      position: absolute;
      width: 12px;
      height: 12px;
      top: 9px;
      margin-left: -6px;
      border-radius: 50%;
      border: 2px solid #fff;
      box-shadow: 0 0 0 1px rgba(9, 30, 50, 0.2);
      cursor: pointer;
      z-index: 3;
    }
    .timeline-comment-dot.matched { background: #1f9c6a; }
    .timeline-comment-dot.missing { background: #cc5d22; }
    .timeline-comment-dot.active {
      box-shadow: 0 0 0 2px rgba(11, 80, 140, 0.38);
    }
    .worklog-row {
      cursor: pointer;
      transition: background .12s ease;
    }
    .worklog-row:hover td {
      background: #f7fbff;
    }
    .worklog-row.selected td {
      background: #edf6ff;
      box-shadow: inset 0 0 0 1px rgba(22, 111, 188, 0.18);
    }
    .chart-design-picker {
      margin-top: 10px;
      border-top: 1px dashed var(--tl-picker-border);
      padding-top: 9px;
      background: var(--tl-picker-bg);
      border-radius: 8px;
      padding-left: 8px;
      padding-right: 8px;
      padding-bottom: 8px;
    }
    .chart-design-picker label {
      color: var(--tl-picker-label);
      font-size: 11px;
      margin-bottom: 4px;
    }
    .recent-line {
      font-size: 12px;
      flex: 1;
      min-width: 0;
      white-space: normal;
      overflow-wrap: anywhere;
    }
    #userPill { max-width: 360px; }
    #debugLogBox {
      margin: 8px 0 0 0;
      max-height: 180px;
      overflow: auto;
      background: #f6f9fd;
      border: 1px solid #d6e3f0;
      border-radius: 10px;
      padding: 10px;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .float {
      position: fixed; right: 12px; bottom: 12px; width: 255px;
      border: 1px solid #b4cae3; border-radius: 11px; padding: 9px;
      background: #eff6ff; display: none; z-index: 9998;
      box-shadow: var(--shadow);
    }
    .float.show { display: block; }
    .modal {
      position: fixed; inset: 0; background: rgba(15, 23, 38, .45);
      display: none; align-items: center; justify-content: center; padding: 12px; z-index: 9999;
    }
    .modal.show { display: flex; }
    .modal-card {
      width: min(560px, 100%);
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      max-height: calc(100vh - 36px);
      overflow: auto;
    }
    .hide { display: none !important; }
    #timerCard,
    #compactBtn,
    #floatBox {
      display: none !important;
    }
    details.debug-panel {
      padding: 0;
    }
    details.debug-panel summary {
      list-style: none;
      cursor: pointer;
      padding: 12px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 14px;
      font-weight: 700;
      color: var(--text);
      user-select: none;
    }
    details.debug-panel summary::-webkit-details-marker {
      display: none;
    }
    details.debug-panel summary::after {
      content: 'Mostrar';
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 3px 8px;
      background: #fff;
    }
    details.debug-panel[open] summary {
      border-bottom: 1px solid #e5eef8;
    }
    details.debug-panel[open] summary::after {
      content: 'Ocultar';
    }
    .debug-body {
      padding: 12px 14px 14px;
    }
    @media (max-width: 1180px) {
      body { padding: 12px; }
    }
    @media (max-width: 700px) {
      .grid2, .grid3 { grid-template-columns: 1fr; }
      .activity-config-grid { grid-template-columns: 1fr; }
      .dashboard-grid { grid-template-columns: 1fr; }
      .panel-timeline,
      .panel-comments,
      .panel-worklogs {
        grid-column: auto;
        grid-row: auto;
      }
      .panel-worklogs .tbl-wrap {
        min-height: 0;
        max-height: 52vh;
      }
      .timeline-head { grid-template-columns: 1fr; }
      .gantt-row { grid-template-columns: 1fr; }
      .timeline-ticket-row { grid-template-columns: 1fr; }
      .timeline-ticket-total { text-align: left; }
      .chart-headline { grid-template-columns: 1fr; }
      .chart-stack-row { grid-template-columns: 1fr; }
      .chart-cards { grid-template-columns: 1fr; }
      .chart-donut-wrap { grid-template-columns: 1fr; }
      .chart-donut { width: 180px; height: 180px; }
      .timeline-meta { grid-template-columns: 1fr; }
      .timeline-lane { grid-template-columns: 1fr; }
      .timeline-lane-track { height: 34px; }
      .float { left: 10px; right: 10px; width: auto; }
      .topbar { gap: 10px; }
      #userPill { max-width: 100%; }
    }
    @media (max-width: 640px) {
      body { padding: 8px; }
      .card { padding: 11px; border-radius: 12px; }
      .timer { font-size: 26px; }
      .btn { width: 100%; justify-content: center; }
      .row > .btn { flex: 1 1 100%; }
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="card row topbar">
      <div>
        <h2>Jira Focus Web</h2>
        <div class="muted">Trabajo en Jira Cloud, frontend puro, persistencia local.</div>
      </div>
      <div class="row" style="margin-left:auto;">
        <span class="pill" id="connPill">Sin conexion</span>
        <span class="pill" id="userPill">Usuario: -</span>
        <button class="btn" id="refreshIssuesBtn" type="button" disabled>Recargar tickets</button>
        <button class="btn danger" id="disconnectBtn" type="button" disabled>Desconectar</button>
      </div>
    </div>

    <div class="msg" id="msg"></div>
    <div class="msg" id="idleMsg"></div>
    <details class="card debug-panel">
      <summary>Logs de depuracion (tecnico)</summary>
      <div class="debug-body">
        <div class="row" style="justify-content:space-between;">
          <div class="muted">No se registran tokens, codes ni secrets. Solo eventos tecnicos.</div>
          <div class="row">
            <button class="btn" id="debugCopyBtn" type="button">Copiar logs</button>
            <button class="btn" id="debugClearBtn" type="button">Limpiar logs</button>
          </div>
        </div>
        <pre id="debugLogBox"></pre>
      </div>
    </details>

    <section class="card" id="loginView">
      <h3>Conectar Jira Cloud</h3>
      <div class="muted">OAuth 2.0 PKCE. Configuracion local en <code>jira_config</code> (sin exponer tokens en UI).</div>
      <div class="grid3" style="margin-top:8px;">
        <div>
          <label for="urlInp">URL Jira</label>
          <input class="inp" id="urlInp" type="url" placeholder="https://tu-dominio.atlassian.net" autocomplete="off">
        </div>
        <div>
          <label for="clientIdInp">Atlassian OAuth Client ID</label>
          <input class="inp" id="clientIdInp" type="text" placeholder="Tu client id 3LO" autocomplete="off">
        </div>
        <div>
          <label for="clientSecretInp">Atlassian OAuth Client Secret</label>
          <input class="inp" id="clientSecretInp" type="password" placeholder="Tu client secret 3LO" autocomplete="new-password">
        </div>
      </div>
      <div class="grid3" style="margin-top:8px;">
        <div>
          <label for="redirectUriInp">Redirect URI</label>
          <input class="inp" id="redirectUriInp" type="url" placeholder="https://tu-app/">
        </div>
      </div>
      <div class="muted" style="margin-top:8px;">
        Registra este Redirect URI en tu app OAuth de Atlassian. Si no se detecta callback automatico, pega la URL retornada:
      </div>
      <div class="grid2" style="margin-top:8px;">
        <div>
          <label for="callbackUrlInp">URL de callback (manual)</label>
          <input class="inp" id="callbackUrlInp" type="text" placeholder="https://tu-app/?code=...&state=...">
        </div>
        <div class="row" style="align-items:flex-end;">
          <button class="btn" id="processCallbackBtn" type="button">Procesar callback</button>
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="connectBtn" type="button">Conectar con OAuth</button>
        <button class="btn danger" id="clearOAuthBtn" type="button">Limpiar sesion OAuth local</button>
      </div>
    </section>

    <section id="mainView" class="hide">
      <div class="card board-head">
        <div class="board-ticket-picker">
          <label for="issueSel">Ticket actual</label>
          <select class="sel" id="issueSel"></select>
        </div>
      </div>

      <div class="hide" aria-hidden="true">
        <button class="btn" id="compactBtn" type="button">Modo compacto</button>
        <div class="activity-config-grid">
          <div>
            <label for="activityTypeSel">Tipo de actividad (oficial)</label>
            <select class="sel" id="activityTypeSel"></select>
          </div>
          <div>
            <label for="activityDueInp">Fecha fin (actividad)</label>
            <input class="inp" id="activityDueInp" type="date">
          </div>
          <div>
            <label for="minutesInp">Duracion (min)</label>
            <input class="inp" id="minutesInp" type="number" min="1" step="1" value="30">
          </div>
          <div class="row" style="margin-top:22px;">
            <button class="btn primary" id="registerBtn" type="button">Registrar worklog</button>
            <span class="pill" id="jiraDurationPill">0m</span>
          </div>
        </div>
        <div style="margin-top:8px;">
          <label for="activityInp">Actividad final</label>
          <input class="inp" id="activityInp" type="text" readonly>
          <datalist id="activityList"></datalist>
        </div>
        <div id="timerCard" class="card">
          <h3>Cronometro laboral</h3>
          <p class="timer" id="timerVal">00:00:00</p>
          <div class="muted" id="timerState">Estado: inactivo</div>
          <div class="muted" style="margin-top:4px;">Horario habil: L-V 08:30 a 18:00.</div>
          <div class="row" style="margin-top:10px;">
            <button class="btn" id="startBtn" type="button">Iniciar</button>
            <button class="btn warn" id="pauseBtn" type="button">Pausar</button>
            <button class="btn" id="resetBtn" type="button">Reiniciar</button>
            <button class="btn" id="applyTimerBtn" type="button">Usar tiempo</button>
          </div>
        </div>
      </div>

      <div class="dashboard-grid">
        <div class="card panel-timeline" id="timelinePanel">
          <h3>Timeline continuo por actividad</h3>
          <div class="activity-focus hide" id="activityFocusBox" aria-hidden="true">
            <label for="activityQuickSel"></label>
            <select class="sel" id="activityQuickSel"></select>
            <div class="muted" id="activityQuickMeta"></div>
          </div>
          <div id="timelineBox" class="empty">Sin registros.</div>
          <div class="hide" aria-hidden="true">
            <h4 style="margin-top:10px;">Gantt por actividad</h4>
            <div id="ganttBox"></div>
            <div class="chart-design-picker">
              <label for="chartDesignSel">Tipo de grafico (10 disenos)</label>
              <select class="sel" id="chartDesignSel"></select>
              <div class="muted" id="chartDesignHelp"></div>
            </div>
          </div>
        </div>
        <div class="card panel-comments">
          <h3>Comentarios del ticket</h3>
          <div id="commentsBox" class="comments"></div>
          <div id="regInlineBox" class="edit-inline hide" style="margin-top:10px;">
            <div class="edit-inline-title">Registrar actividad</div>
            <div class="muted" id="regInlineMeta"></div>
            <div class="grid3" style="margin-top:8px;">
              <div>
                <label for="regTypeSel">Actividad (oficial)</label>
                <select id="regTypeSel" class="sel"></select>
              </div>
              <div><label for="regDateInp">Fecha fin</label><input id="regDateInp" class="inp" type="date"></div>
              <div><label for="regMinInp">Duracion (min)</label><input id="regMinInp" class="inp" type="number" min="1" step="1"></div>
            </div>
            <div class="row" style="margin-top:10px;">
              <button class="btn primary" id="regInlineOkBtn" type="button">Registrar</button>
              <button class="btn" id="regInlineCancelBtn" type="button">Cancelar</button>
            </div>
          </div>
        </div>
        <div class="card panel-worklogs">
          <h3>Historial editable por ticket</h3>
          <div class="tbl-wrap">
            <table>
              <thead><tr><th>Fecha</th><th>Actividad</th><th>Duracion</th><th>Acciones</th></tr></thead>
              <tbody id="worklogBody"></tbody>
            </table>
          </div>
          <div id="editInlineBox" class="edit-inline hide">
            <div class="edit-inline-title">Editar worklog</div>
            <div class="muted" id="editMeta"></div>
            <div class="grid3" style="margin-top:8px;">
              <div>
                <label for="editTypeSel">Actividad (oficial)</label>
                <select id="editTypeSel" class="sel"></select>
              </div>
              <div><label for="editDateInp">Fecha</label><input id="editDateInp" class="inp" type="date"></div>
              <div><label for="editTimeInp">Hora</label><input id="editTimeInp" class="inp" type="time" step="60"></div>
            </div>
            <div class="grid2" style="margin-top:8px;">
              <div><label for="editMinInp">Duracion (min)</label><input id="editMinInp" class="inp" type="number" min="1" step="1"></div>
              <div><label for="editActInp">Actividad final</label><input id="editActInp" class="inp" type="text" readonly></div>
            </div>
            <div class="row" style="margin-top:10px;">
              <button class="btn primary" id="editSaveBtn" type="button">Guardar</button>
              <button class="btn danger" id="editDeleteBtn" type="button">Eliminar</button>
              <button class="btn" id="editCancelBtn" type="button">Cancelar</button>
            </div>
          </div>
        </div>
      </div>

      <div class="hide" aria-hidden="true">
        <div id="suggestionBox"></div>
        <button id="applySugActBtn" type="button"></button>
        <button id="applySugTimeBtn" type="button"></button>
        <button id="registerSugBtn" type="button"></button>
      </div>

      <div id="dashboardCard" class="card hide" style="margin-top:10px;">
        <h3>Dashboard global</h3>
        <div class="grid3">
          <div class="card" style="padding:8px;">
            <div class="muted">Total hoy</div>
            <div id="todayTotal" style="font-weight:700;font-size:18px;">0m</div>
          </div>
          <div class="card" style="padding:8px;">
            <div class="muted">Total semana</div>
            <div id="weekTotal" style="font-weight:700;font-size:18px;">0m</div>
          </div>
          <div class="card" style="padding:8px;">
            <div class="muted">Tickets con registros</div>
            <div id="issueCount" style="font-weight:700;font-size:18px;">0</div>
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <button class="btn" id="refreshDashBtn" type="button">Actualizar dashboard</button>
          <span class="muted" id="dashMeta">Sin datos.</span>
        </div>
        <div id="recentBox" class="empty" style="margin-top:8px;">Sin historial reciente.</div>
      </div>

      <div id="reportCard" class="card hide" style="margin-top:10px;">
        <h3>Reporte plantilla + .xlsx</h3>
        <div class="muted">Detecta comentarios con "plantilla" y adjuntos/links .xlsx. Agrupa por colegio segun resumen normalizado.</div>
        <div class="row" style="margin-top:10px;">
          <button class="btn primary" id="genReportBtn" type="button">Generar reporte</button>
          <button class="btn" id="exportReportBtn" type="button" disabled>Exportar Excel</button>
        </div>
        <div class="muted" id="reportMeta" style="margin-top:8px;">Sin reporte.</div>
        <div class="tbl-wrap" style="margin-top:8px;">
          <table>
            <thead><tr><th>Colegio</th><th>Tickets</th><th>Comentarios</th><th>Adjuntos .xlsx</th></tr></thead>
            <tbody id="reportBody"></tbody>
          </table>
        </div>
      </div>
    </section>
  </div>

  <div class="float" id="floatBox">
    <div class="muted" id="floatIssue">-</div>
    <div style="font-size:26px;font-weight:700;font-variant-numeric:tabular-nums;" id="floatTimer">00:00:00</div>
    <div class="muted" id="floatState">Estado: inactivo</div>
    <div class="row" style="margin-top:8px;">
      <button class="btn" id="floatStartBtn" type="button">Iniciar</button>
      <button class="btn warn" id="floatPauseBtn" type="button">Pausar</button>
      <button class="btn" id="floatExpandBtn" type="button">Expandir</button>
    </div>
  </div>

  <div class="hide" aria-hidden="true"></div>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    (() => {
      'use strict';

      const STORAGE = {
        config: 'jira_config',
        oauthTokens: 'jira_oauth_tokens',
        oauthPending: 'jira_oauth_pending',
        oauthDone: 'jira_oauth_done',
        timer: 'jira_focus_timer_state',
        ui: 'jira_focus_ui_state',
        lastActivity: 'jira_focus_last_activity',
        activities: 'jira_focus_activities'
      };
      const OAUTH = {
        authorizeUrl: 'https://auth.atlassian.com/authorize',
        tokenUrl: 'https://auth.atlassian.com/oauth/token',
        resourcesUrl: 'https://api.atlassian.com/oauth/token/accessible-resources',
        scopes: [
          'read:jira-user',
          'read:jira-work',
          'write:jira-work',
          'delete:jira-work',
          'offline_access'
        ]
      };
      const DEBUG_MAX = 140;
      const LABOR = { startHour: 8, startMinute: 30, endHour: 18, endMinute: 0, dayMinutes: 570, weekMinutes: 2850 };
      const INACTIVITY_MS = 2 * 60 * 60 * 1000;
      const SUGGESTION_MS = 3 * 24 * 60 * 60 * 1000;
      const OFFICIAL_ACTIVITY_TYPES = [
        'Configuración Agente de Éxito',
        'Estandarización de plantillas',
        'Entrega de plantillas DOCENTES Coach/Farmer/Hunter',
        'Entrega de plantillas ESTUDIANTES Coach/Farmer/Hunter',
        'Pendiente información',
        'Integración LQL',
        'Integración RLP',
        'Integración LDB',
        'Integración WeMath',
        'Integración Pleno',
        'Configuración de colegio',
        'Configuración de docentes',
        'Configuración de estudiantes',
        'Integración Studio'
      ];
      const ACTIVITY_PALETTE = [
        '#1b78c4', '#1f8f71', '#e07a2f', '#7a57c2', '#c63f69', '#3e8f5b', '#2e7fba',
        '#aa5d13', '#5f7bca', '#0f8fa8', '#b0453e', '#1d9164', '#8568c8', '#ad4c88'
      ];
      const CHART_DESIGNS = [
        { id: 'classic', label: '1. Timeline + Gantt (clasico)', help: 'Linea de tiempo arriba y Gantt por actividad abajo.' },
        { id: 'compact', label: '2. Compacto por actividad', help: 'Resumen rapido por actividad con barras simples.' },
        { id: 'ranking', label: '3. Ranking de actividades', help: 'Ordena actividades por tiempo de mayor a menor.' },
        { id: 'cards', label: '4. Tarjetas de progreso', help: 'Cada actividad en una tarjeta con porcentaje.' },
        { id: 'donut', label: '5. Donut de distribucion', help: 'Distribucion del tiempo total por actividad.' },
        { id: 'weekly', label: '6. Vista semanal', help: 'Agrupa el trabajo por semanas calendario.' },
        { id: 'daily', label: '7. Vista diaria', help: 'Agrupa el trabajo por dia para detectar picos.' },
        { id: 'steps', label: '8. Flujo cronologico', help: 'Lista paso a paso de registros en orden de tiempo.' },
        { id: 'matrix', label: '9. Matriz actividad/semana', help: 'Cruza actividad contra semanas para ver cobertura.' },
        { id: 'table', label: '10. Tabla clara (simple)', help: 'Vista mas entendible y facil de leer para operacion.' }
      ];
      const DEFAULT_CHART_DESIGN = 'table';
      const FEATURES = {
        dashboard: false,
        report: false
      };

      const state = {
        connected: false,
        config: null,
        me: null,
        issues: [],
        selectedIssueKey: '',
        activity: '',
        activityType: OFFICIAL_ACTIVITY_TYPES[0],
        activityDueDate: '',
        durationMinutes: 30,
        commentsByIssue: {},
        worklogsByIssue: {},
        suggestion: null,
        compact: false,
        report: { detail: [], grouped: [] },
        dash: { logs: [], today: 0, week: 0, issueCount: 0, refreshedAt: null },
        timer: { running: false, resumeTs: 0, elapsedBizMs: 0 },
        oauthTokens: null,
        lastActivityTs: Date.now(),
        lastReminderTs: 0,
        regCtx: null,
        editCtx: null,
        selectedCommentId: '',
        selectedTimelineActivity: '',
        selectedTimelineMinutes: 0,
        selectedWorklogId: '',
        timelineLinksByIssue: {},
        chartDesign: DEFAULT_CHART_DESIGN,
        activities: [],
        debugLogs: [],
        popupWatchTimer: 0,
        popupProcessing: false,
        oauthCallbackInProgress: false
      };

      const el = {};
      const StorageService = {
        parse(raw, fb) { try { return raw ? JSON.parse(raw) : fb; } catch (_e) { return fb; } },
        get(key) { try { return localStorage.getItem(key); } catch (_e) { return null; } },
        set(key, val) { try { localStorage.setItem(key, val); } catch (_e) {} },
        del(key) { try { localStorage.removeItem(key); } catch (_e) {} },
        getConfig() {
          const cfg = this.parse(this.get(STORAGE.config), null);
          if (!cfg || typeof cfg !== 'object') return null;
          const url = sanitizeUrl(cfg.url || '');
          const client_id = String(cfg.client_id || '').trim();
          const client_secret = String(cfg.client_secret || '');
          const redirect_uri = String(cfg.redirect_uri || '').trim();
          const cloud_id = String(cfg.cloud_id || '').trim();
          if (!url || !client_id || !client_secret || !redirect_uri) return null;
          return {
            url,
            client_id,
            client_secret,
            redirect_uri,
            cloud_id,
            // keep compatibility fields expected by old config shape
            email: String(cfg.email || '').trim(),
            api_token: String(cfg.api_token || '')
          };
        },
        saveConfig(cfg) {
          this.set(STORAGE.config, JSON.stringify({
            url: sanitizeUrl(cfg.url || ''),
            email: '',
            api_token: '',
            client_id: String(cfg.client_id || '').trim(),
            client_secret: String(cfg.client_secret || ''),
            redirect_uri: String(cfg.redirect_uri || '').trim(),
            cloud_id: String(cfg.cloud_id || '').trim()
          }));
        },
        getOAuthTokens() {
          const tokenData = this.parse(this.get(STORAGE.oauthTokens), null);
          if (!tokenData || typeof tokenData !== 'object') return null;
          const access_token = String(tokenData.access_token || '');
          const refresh_token = String(tokenData.refresh_token || '');
          const expires_at = Number(tokenData.expires_at || 0);
          if (!access_token || !expires_at) return null;
          return { access_token, refresh_token, expires_at };
        },
        saveOAuthTokens(tokens) {
          this.set(STORAGE.oauthTokens, JSON.stringify({
            access_token: String(tokens.access_token || ''),
            refresh_token: String(tokens.refresh_token || ''),
            expires_at: Number(tokens.expires_at || 0)
          }));
        },
        clearOAuthTokens() {
          this.del(STORAGE.oauthTokens);
        },
        getOAuthPending() {
          const pending = this.parse(this.get(STORAGE.oauthPending), null);
          if (!pending || typeof pending !== 'object') return null;
          const state = String(pending.state || '');
          const code_verifier = String(pending.code_verifier || '');
          const created_at = Number(pending.created_at || 0);
          if (!state || !code_verifier || !created_at) return null;
          return pending;
        },
        saveOAuthPending(payload) {
          this.set(STORAGE.oauthPending, JSON.stringify(payload || {}));
        },
        clearOAuthPending() {
          this.del(STORAGE.oauthPending);
        },
        markOAuthDone(source) {
          this.set(STORAGE.oauthDone, JSON.stringify({
            at: Date.now(),
            source: String(source || '')
          }));
        },
        clearOAuthDone() {
          this.del(STORAGE.oauthDone);
        },
        getTimer() {
          const t = this.parse(this.get(STORAGE.timer), null);
          if (!t) return null;
          return { running: !!t.running, resumeTs: Number(t.resumeTs || 0), elapsedBizMs: Number(t.elapsedBizMs || 0) };
        },
        saveTimer(t) {
          this.set(STORAGE.timer, JSON.stringify({ running: !!t.running, resumeTs: Number(t.resumeTs || 0), elapsedBizMs: Number(t.elapsedBizMs || 0) }));
        },
        getUI() { return this.parse(this.get(STORAGE.ui), {}) || {}; },
        saveUI(v) { this.set(STORAGE.ui, JSON.stringify(v || {})); },
        getLastActivity() {
          const ts = Number(this.get(STORAGE.lastActivity));
          return Number.isFinite(ts) && ts > 0 ? ts : Date.now();
        },
        saveLastActivity(ts) { this.set(STORAGE.lastActivity, String(Number(ts || Date.now()))); },
        getActivities() {
          const list = this.parse(this.get(STORAGE.activities), []);
          return Array.isArray(list) ? list.filter((x) => typeof x === 'string' && x.trim()).slice(0, 100) : [];
        },
        saveActivities(list) {
          this.set(STORAGE.activities, JSON.stringify((list || []).slice(0, 100)));
        }
      };

      const TimeService = {
        isWeekday(d) { const day = d.getDay(); return day >= 1 && day <= 5; },
        dayWindow(d) {
          if (!this.isWeekday(d)) return null;
          const start = new Date(d); start.setHours(LABOR.startHour, LABOR.startMinute, 0, 0);
          const end = new Date(d); end.setHours(LABOR.endHour, LABOR.endMinute, 0, 0);
          return { start, end };
        },
        isBusinessNow(d) {
          const w = this.dayWindow(d);
          return !!w && d >= w.start && d <= w.end;
        },
        businessMsBetween(a, b) {
          const start = new Date(a); const end = new Date(b);
          if (!(start < end)) return 0;
          let total = 0;
          let cur = new Date(start);
          while (cur < end) {
            const w = this.dayWindow(cur);
            if (w) {
              const s = Math.max(cur.getTime(), w.start.getTime());
              const e = Math.min(end.getTime(), w.end.getTime());
              if (e > s) total += (e - s);
            }
            cur.setHours(24, 0, 0, 0);
          }
          return total;
        },
        businessMinutesBetween(a, b) { return Math.floor(this.businessMsBetween(a, b) / 60000); },
        prevBusinessEnd(dateIn) {
          const d = new Date(dateIn);
          while (true) {
            d.setDate(d.getDate() - 1);
            const w = this.dayWindow(d);
            if (w) return new Date(w.end);
          }
        },
        subtractBusinessMinutes(endIn, minsIn) {
          let remain = Math.max(0, Math.floor(Number(minsIn || 0)));
          let cur = new Date(endIn);
          if (!remain) return cur;
          while (remain > 0) {
            const w = this.dayWindow(cur);
            if (!w) { cur = this.prevBusinessEnd(cur); continue; }
            if (cur > w.end) cur = new Date(w.end);
            if (cur <= w.start) { cur = this.prevBusinessEnd(cur); continue; }
            const available = Math.floor((cur.getTime() - w.start.getTime()) / 60000);
            if (available >= remain) {
              cur = new Date(cur.getTime() - remain * 60000);
              remain = 0;
            } else {
              remain -= available;
              cur = this.prevBusinessEnd(cur);
            }
          }
          return cur;
        },
        hhmmss(msIn) {
          const total = Math.floor(Math.max(0, Number(msIn || 0)) / 1000);
          const h = Math.floor(total / 3600);
          const m = Math.floor((total % 3600) / 60);
          const s = total % 60;
          return [h, m, s].map((x) => String(x).padStart(2, '0')).join(':');
        },
        ddmmyyyy(dIn) {
          const d = new Date(dIn);
          const dd = String(d.getDate()).padStart(2, '0');
          const mm = String(d.getMonth() + 1).padStart(2, '0');
          return `${dd}/${mm}/${d.getFullYear()}`;
        },
        dtLabel(dIn) {
          const d = new Date(dIn);
          const hh = String(d.getHours()).padStart(2, '0');
          const mi = String(d.getMinutes()).padStart(2, '0');
          return `${this.ddmmyyyy(d)} ${hh}:${mi}`;
        },
        jiraDateTime(dIn) {
          const d = new Date(dIn);
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          const hh = String(d.getHours()).padStart(2, '0');
          const mi = String(d.getMinutes()).padStart(2, '0');
          const ss = String(d.getSeconds()).padStart(2, '0');
          const off = -d.getTimezoneOffset();
          const sign = off >= 0 ? '+' : '-';
          const abs = Math.abs(off);
          const oh = String(Math.floor(abs / 60)).padStart(2, '0');
          const om = String(abs % 60).padStart(2, '0');
          return `${y}-${m}-${day}T${hh}:${mi}:${ss}.000${sign}${oh}${om}`;
        },
        jiraDuration(minsIn) {
          let mins = Math.max(0, Math.floor(Number(minsIn || 0)));
          const parts = [];
          const w = Math.floor(mins / LABOR.weekMinutes); mins -= w * LABOR.weekMinutes;
          const d = Math.floor(mins / LABOR.dayMinutes); mins -= d * LABOR.dayMinutes;
          const h = Math.floor(mins / 60); mins -= h * 60;
          if (w) parts.push(`${w}w`);
          if (d) parts.push(`${d}d`);
          if (h) parts.push(`${h}h`);
          if (mins || !parts.length) parts.push(`${mins}m`);
          return parts.join(' ');
        },
        startOfToday() { const d = new Date(); d.setHours(0, 0, 0, 0); return d; },
        startOfWeek() {
          const d = new Date();
          const day = d.getDay();
          const diff = day === 0 ? -6 : 1 - day;
          d.setDate(d.getDate() + diff);
          d.setHours(0, 0, 0, 0);
          return d;
        },
        toInputDate(dIn) {
          const d = new Date(dIn);
          return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
        },
        toInputTime(dIn) {
          const d = new Date(dIn);
          return `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
        }
      };

      function isValidInputDate(value) {
        const text = String(value || '').trim();
        if (!/^\d{4}-\d{2}-\d{2}$/.test(text)) return false;
        const d = new Date(`${text}T00:00:00`);
        return !Number.isNaN(d.getTime()) && TimeService.toInputDate(d) === text;
      }

      function inputDateToDdmmyyyy(value) {
        const text = String(value || '').trim();
        if (!isValidInputDate(text)) return '';
        const [y, m, d] = text.split('-');
        return `${d}/${m}/${y}`;
      }

      function ddmmyyyyToInputDate(value) {
        const text = String(value || '').trim();
        const m = text.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
        if (!m) return '';
        const input = `${m[3]}-${m[2]}-${m[1]}`;
        return isValidInputDate(input) ? input : '';
      }

      function buildOfficialActivity(typeName, dueInputDate) {
        const type = OFFICIAL_ACTIVITY_TYPES.includes(String(typeName || '').trim())
          ? String(typeName || '').trim()
          : OFFICIAL_ACTIVITY_TYPES[0];
        const due = isValidInputDate(dueInputDate) ? dueInputDate : TimeService.toInputDate(new Date());
        const dueDdmmyyyy = inputDateToDdmmyyyy(due);
        return `[${type}] [${dueDdmmyyyy}]`;
      }

      function parseOfficialActivity(text) {
        const raw = String(text || '').trim();
        const match = raw.match(/^\[(.+?)\]\s+\[(\d{2}\/\d{2}\/\d{4})\]$/);
        if (!match) return null;
        const type = String(match[1] || '').trim();
        const dueDdmmyyyy = String(match[2] || '').trim();
        const dueInput = ddmmyyyyToInputDate(dueDdmmyyyy);
        if (!dueInput || !OFFICIAL_ACTIVITY_TYPES.includes(type)) {
          return null;
        }
        return { type, dueInput };
      }

      function worklogCommentFromActivity(activityValue, refDate) {
        const act = String(activityValue || '').trim();
        if (!act) return '';
        if (parseOfficialActivity(act)) {
          return act;
        }
        const fallbackDate = TimeService.ddmmyyyy(refDate || new Date());
        return `[${act}] [${fallbackDate}]`;
      }

      function hashText(input) {
        const text = String(input || '');
        let hash = 0;
        for (let i = 0; i < text.length; i += 1) {
          hash = ((hash << 5) - hash + text.charCodeAt(i)) | 0;
        }
        return Math.abs(hash);
      }

      function activityColor(activityName) {
        const act = String(activityName || '').trim();
        if (!act) return ACTIVITY_PALETTE[0];
        const officialIndex = OFFICIAL_ACTIVITY_TYPES.findIndex((name) => name.toLowerCase() === act.toLowerCase());
        const idx = officialIndex >= 0 ? officialIndex : (hashText(act) % ACTIVITY_PALETTE.length);
        return ACTIVITY_PALETTE[idx % ACTIVITY_PALETTE.length];
      }

      const OAuthService = {
        async sha256Base64Url(input) {
          const data = new TextEncoder().encode(String(input || ''));
          const digest = await crypto.subtle.digest('SHA-256', data);
          return base64UrlEncode(new Uint8Array(digest));
        },
        randomString(size) {
          const bytes = new Uint8Array(size);
          crypto.getRandomValues(bytes);
          return base64UrlEncode(bytes).slice(0, size * 2);
        },
        async startAuth(cfg, popupWindow) {
          dbg('oauth_start', {
            jira_host: safeHostname(cfg.url),
            redirect_host: safeHostname(cfg.redirect_uri),
            has_client_secret: !!cfg.client_secret,
            has_popup: !!popupWindow
          });
          const codeVerifier = this.randomString(64);
          const codeChallenge = await this.sha256Base64Url(codeVerifier);
          const oauthState = this.randomString(32);
          StorageService.saveOAuthPending({
            state: oauthState,
            code_verifier: codeVerifier,
            created_at: Date.now(),
            redirect_uri: cfg.redirect_uri,
            url: cfg.url,
            client_id: cfg.client_id
          });
          const authUrl = new URL(OAUTH.authorizeUrl);
          authUrl.searchParams.set('audience', 'api.atlassian.com');
          authUrl.searchParams.set('client_id', cfg.client_id);
          authUrl.searchParams.set('scope', OAUTH.scopes.join(' '));
          authUrl.searchParams.set('redirect_uri', cfg.redirect_uri);
          authUrl.searchParams.set('state', oauthState);
          authUrl.searchParams.set('response_type', 'code');
          authUrl.searchParams.set('prompt', 'consent');
          authUrl.searchParams.set('code_challenge', codeChallenge);
          authUrl.searchParams.set('code_challenge_method', 'S256');
          navigateTop(authUrl.toString(), popupWindow);
        },
        async tokenRequest(payload) {
          dbg('oauth_token_request', { grant_type: payload && payload.grant_type ? payload.grant_type : '' });
          let res;
          try {
            res = await fetch(OAUTH.tokenUrl, {
              method: 'POST',
              headers: { Accept: 'application/json', 'Content-Type': 'application/json' },
              body: JSON.stringify(payload || {})
            });
          } catch (_e) {
            const err = new Error('No se pudo llegar a auth.atlassian.com (posible bloqueo de red/CORS).');
            err.kind = 'cors';
            throw err;
          }
          const raw = await res.text();
          let data = null;
          if (raw) {
            try { data = JSON.parse(raw); } catch (_e) { data = null; }
          }
          dbg('oauth_token_response', { status: res.status, ok: res.ok });
          if (!res.ok) {
            dbg('oauth_token_error_payload', data && typeof data === 'object' ? data : { raw: raw ? raw.slice(0, 200) : '' });
            const err = new Error(httpMessage(data, res.status));
            err.kind = 'oauth';
            err.status = res.status;
            throw err;
          }
          return data || {};
        },
        async exchangeCode(cfg, code, codeVerifier) {
          const data = await this.tokenRequest({
            grant_type: 'authorization_code',
            client_id: cfg.client_id,
            client_secret: cfg.client_secret,
            code: String(code || ''),
            redirect_uri: cfg.redirect_uri,
            code_verifier: codeVerifier
          });
          return this.normalizeTokenPayload(data);
        },
        async refresh(cfg, refreshToken) {
          const data = await this.tokenRequest({
            grant_type: 'refresh_token',
            client_id: cfg.client_id,
            client_secret: cfg.client_secret,
            refresh_token: String(refreshToken || '')
          });
          return this.normalizeTokenPayload(data, refreshToken);
        },
        normalizeTokenPayload(data, fallbackRefreshToken) {
          const accessToken = String(data.access_token || '');
          const refreshToken = String(data.refresh_token || fallbackRefreshToken || '');
          const expiresIn = Number(data.expires_in || 0);
          if (!accessToken || !expiresIn) {
            const err = new Error('Respuesta OAuth incompleta.');
            err.kind = 'oauth';
            throw err;
          }
          return {
            access_token: accessToken,
            refresh_token: refreshToken,
            expires_at: Date.now() + Math.max(60, expiresIn - 45) * 1000
          };
        },
        async ensureValidTokens(cfg) {
          const current = StorageService.getOAuthTokens();
          if (!current) {
            const err = new Error('No existe sesion OAuth en localStorage.');
            err.kind = 'oauth';
            err.status = 401;
            throw err;
          }
          const stillValid = current.expires_at > Date.now() + 15000;
          if (stillValid) {
            state.oauthTokens = current;
            return current;
          }
          if (!current.refresh_token) {
            StorageService.clearOAuthTokens();
            const err = new Error('Sesion expirada. Reconecta OAuth.');
            err.kind = 'oauth';
            err.status = 401;
            throw err;
          }
          const refreshed = await this.refresh(cfg, current.refresh_token);
          StorageService.saveOAuthTokens(refreshed);
          state.oauthTokens = refreshed;
          return refreshed;
        },
        async getResources(accessToken) {
          let res;
          try {
            res = await fetch(OAUTH.resourcesUrl, {
              method: 'GET',
              headers: {
                Accept: 'application/json',
                Authorization: `Bearer ${accessToken}`
              }
            });
          } catch (_e) {
            const err = new Error('No se pudo consultar accessible-resources (CORS/red).');
            err.kind = 'cors';
            throw err;
          }
          const raw = await res.text();
          let data = null;
          if (raw) {
            try { data = JSON.parse(raw); } catch (_e) { data = null; }
          }
          if (!res.ok) {
            const err = new Error(httpMessage(data, res.status));
            err.kind = 'oauth';
            err.status = res.status;
            throw err;
          }
          return Array.isArray(data) ? data : [];
        },
        pickCloudResource(resources, jiraUrl) {
          const site = sanitizeUrl(jiraUrl);
          const siteHost = safeHostname(site);
          let match = resources.find((r) => sanitizeUrl(r.url || '') === site);
          if (!match && siteHost) {
            match = resources.find((r) => safeHostname(r.url || '') === siteHost);
          }
          if (!match && resources.length === 1) {
            match = resources[0];
          }
          if (!match) {
            const err = new Error('No se encontro recurso accesible para la URL Jira indicada.');
            err.kind = 'oauth';
            err.status = 404;
            throw err;
          }
          return match;
        }
      };

      const JiraService = {
        cloudId: '',
        setCloudId(cloudId) {
          this.cloudId = String(cloudId || '').trim();
        },
        url(path, params) {
          if (!this.cloudId) {
            throw new Error('cloudId no configurado.');
          }
          const base = `https://api.atlassian.com/ex/jira/${encodeURIComponent(this.cloudId)}`;
          const u = new URL(base + path);
          Object.entries(params || {}).forEach(([k, v]) => {
            if (v === undefined || v === null || v === '') return;
            u.searchParams.append(k, String(v));
          });
          return u.toString();
        },
        async req(method, path, opts = {}, retried = false) {
          const cfg = StorageService.getConfig();
          if (!cfg) {
            const err = new Error('No existe configuracion OAuth.');
            err.kind = 'oauth';
            err.status = 401;
            throw err;
          }
          const tokens = await OAuthService.ensureValidTokens(cfg);
          const init = {
            method,
            headers: {
              Accept: 'application/json',
              'Content-Type': 'application/json',
              Authorization: `Bearer ${tokens.access_token}`
            }
          };
          if (opts.body !== undefined) init.body = JSON.stringify(opts.body);
          let res;
          try {
            res = await fetch(this.url(path, opts.params || {}), init);
          } catch (_e) {
            const err = new Error('No se pudo conectar directo a Jira Cloud (posible CORS/red).');
            err.kind = 'cors';
            throw err;
          }
          const raw = await res.text();
          let payload = null;
          if (raw) { try { payload = JSON.parse(raw); } catch (_e) { payload = null; } }
          if (!res.ok) {
            if (res.status === 401 && !retried) {
              try {
                await OAuthService.refresh(cfg, tokens.refresh_token).then((newTokens) => {
                  StorageService.saveOAuthTokens(newTokens);
                  state.oauthTokens = newTokens;
                });
                return this.req(method, path, opts, true);
              } catch (_refreshError) {
                StorageService.clearOAuthTokens();
              }
            }
            const err = new Error(httpMessage(payload, res.status));
            err.kind = 'http';
            err.status = res.status;
            throw err;
          }
          return payload || {};
        },
        myself() { return this.req('GET', '/rest/api/3/myself'); },
        searchIssues() {
          const jql = 'assignee = currentUser() AND statusCategory != Done AND issuetype not in subTaskIssueTypes() ORDER BY updated DESC';
          return this.req('GET', '/rest/api/3/search/jql', { params: { jql, maxResults: 80, fields: 'summary,status,issuetype,attachment' } });
        },
        comments(key) { return this.req('GET', `/rest/api/3/issue/${encodeURIComponent(key)}/comment`, { params: { orderBy: '-created', maxResults: 100 } }); },
        worklogs(key) { return this.req('GET', `/rest/api/3/issue/${encodeURIComponent(key)}/worklog`); },
        addWorklog(key, body) { return this.req('POST', `/rest/api/3/issue/${encodeURIComponent(key)}/worklog`, { body }); },
        updateWorklog(key, id, body) { return this.req('PUT', `/rest/api/3/issue/${encodeURIComponent(key)}/worklog/${encodeURIComponent(id)}`, { body }); },
        deleteWorklog(key, id) { return this.req('DELETE', `/rest/api/3/issue/${encodeURIComponent(key)}/worklog/${encodeURIComponent(id)}`); }
      };

      function sanitizeUrl(url) {
        const base = String(url || '').trim().replace(/\/+$/, '');
        if (!base) return '';
        if (/^https?:\/\//i.test(base)) return base;
        return `https://${base}`;
      }

      function safeHostname(url) {
        try {
          return new URL(sanitizeUrl(url)).hostname.toLowerCase();
        } catch (_e) {
          return '';
        }
      }

      function base64UrlEncode(bytes) {
        let str = '';
        const source = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes || []);
        source.forEach((b) => { str += String.fromCharCode(b); });
        return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      }

      function parseUrlParams(urlValue) {
        try {
          const url = new URL(String(urlValue || ''));
          return {
            code: url.searchParams.get('code') || '',
            state: url.searchParams.get('state') || '',
            error: url.searchParams.get('error') || '',
            error_description: url.searchParams.get('error_description') || ''
          };
        } catch (_e) {
          return { code: '', state: '', error: '', error_description: '' };
        }
      }

      function sanitizeDebugMeta(input) {
        const secretKeys = new Set([
          'code',
          'state',
          'authorization',
          'access_token',
          'refresh_token',
          'id_token',
          'token',
          'api_token',
          'client_secret',
          'code_verifier',
          'password'
        ]);
        const walk = (value, keyName) => {
          if (keyName) {
            const key = String(keyName || '').toLowerCase();
            if (secretKeys.has(key) || key.endsWith('_token') || key.endsWith('_secret')) {
              return '[REDACTED]';
            }
          }
          if (value === null || value === undefined) {
            return value;
          }
          if (typeof value === 'string') {
            if (value.length > 160) {
              return `${value.slice(0, 160)}...`;
            }
            if (/^Bearer\s+/i.test(value)) {
              return '[REDACTED]';
            }
            return value;
          }
          if (typeof value === 'number' || typeof value === 'boolean') {
            return value;
          }
          if (Array.isArray(value)) {
            return value.slice(0, 25).map((item) => walk(item, keyName));
          }
          if (typeof value === 'object') {
            const out = {};
            Object.keys(value).slice(0, 40).forEach((k) => {
              out[k] = walk(value[k], k);
            });
            return out;
          }
          return String(value);
        };
        return walk(input, '');
      }

      function renderDebugLogs() {
        if (!el.debugLogBox) {
          return;
        }
        const lines = state.debugLogs.length ? state.debugLogs : ['(sin logs)'];
        el.debugLogBox.textContent = lines.join('\n');
      }

      function dbg(eventName, meta) {
        const stamp = new Date().toISOString();
        let line = `[${stamp}] ${eventName}`;
        if (meta !== undefined) {
          try {
            line += ` | ${JSON.stringify(sanitizeDebugMeta(meta))}`;
          } catch (_e) {
            line += ' | {"meta":"(error serializando)"}';
          }
        }
        state.debugLogs.push(line);
        if (state.debugLogs.length > DEBUG_MAX) {
          state.debugLogs = state.debugLogs.slice(state.debugLogs.length - DEBUG_MAX);
        }
        renderDebugLogs();
      }

      function openOAuthPopupWindow() {
        try {
          const popup = window.open('', 'jira_oauth_login', 'popup=yes,width=560,height=760');
          if (popup) {
            dbg('oauth_popup_opened');
          } else {
            dbg('oauth_popup_blocked');
          }
          return popup;
        } catch (error) {
          dbg('oauth_popup_error', { message: error && error.message ? error.message : String(error) });
          return null;
        }
      }

      function isOAuthPopupContext() {
        try {
          if (window.name === 'jira_oauth_login') {
            return true;
          }
          return !!(window.opener && window.opener !== window);
        } catch (_e) {
          return false;
        }
      }

      function tryCloseOAuthPopup(reason) {
        if (!isOAuthPopupContext()) {
          return false;
        }
        dbg('oauth_popup_close_attempt', { reason: String(reason || '') });
        window.setTimeout(() => {
          try {
            window.close();
            dbg('oauth_popup_close_called', { reason: String(reason || '') });
          } catch (error) {
            dbg('oauth_popup_close_failed', { reason: String(reason || ''), message: error && error.message ? error.message : String(error) });
          }
        }, 450);
        return true;
      }

      function normalizeRedirectForCompare(urlValue) {
        try {
          const url = new URL(String(urlValue || ''));
          const path = (url.pathname || '/').replace(/\/+$/, '') || '/';
          return `${url.origin}${path}`;
        } catch (_e) {
          return '';
        }
      }

      function isRedirectUriMatch(urlValue, redirectUri) {
        const left = normalizeRedirectForCompare(urlValue);
        const right = normalizeRedirectForCompare(redirectUri);
        return !!left && !!right && left === right;
      }

      function clearPopupWatcher() {
        if (state.popupWatchTimer) {
          window.clearInterval(state.popupWatchTimer);
          state.popupWatchTimer = 0;
        }
        state.popupProcessing = false;
      }

      function closePopupWindowRef(popupWindow, reason) {
        if (!popupWindow) return;
        try {
          if (popupWindow.closed) {
            dbg('oauth_popup_already_closed', { reason: String(reason || '') });
            return;
          }
        } catch (_e) {
          // ignore and try close anyway
        }
        try {
          popupWindow.close();
          dbg('oauth_popup_closed_by_parent', { reason: String(reason || '') });
        } catch (error) {
          dbg('oauth_popup_close_by_parent_failed', {
            reason: String(reason || ''),
            message: error && error.message ? error.message : String(error)
          });
        }
        window.setTimeout(() => {
          try {
            if (popupWindow && !popupWindow.closed) {
              popupWindow.close();
              dbg('oauth_popup_closed_by_parent_retry', { reason: String(reason || '') });
            }
          } catch (error) {
            dbg('oauth_popup_close_by_parent_retry_failed', {
              reason: String(reason || ''),
              message: error && error.message ? error.message : String(error)
            });
          }
        }, 700);
      }

      function watchOAuthPopupCallback(popupWindow, cfg) {
        clearPopupWatcher();
        dbg('oauth_popup_watch_start', {
          redirect_host: safeHostname(cfg.redirect_uri)
        });
        state.popupWatchTimer = window.setInterval(() => {
          if (state.popupProcessing) {
            return;
          }
          if (!popupWindow || popupWindow.closed) {
            dbg('oauth_popup_closed_before_callback');
            clearPopupWatcher();
            return;
          }
          let href = '';
          try {
            href = String(popupWindow.location.href || '');
          } catch (_e) {
            return;
          }
          if (!href || !isRedirectUriMatch(href, cfg.redirect_uri)) {
            return;
          }
          const params = parseUrlParams(href);
          if (!params.code && !params.error) {
            return;
          }
          state.popupProcessing = true;
          dbg('oauth_popup_callback_detected', {
            has_code: !!params.code,
            has_error: !!params.error
          });
          Promise.resolve(processOAuthCallback(href, false))
            .then((processed) => {
              if (processed) {
                showMsg('ok', 'Callback OAuth recibido automaticamente.');
              } else {
                showMsg('error', 'La ventana OAuth regreso sin parametros esperados.');
              }
              closePopupWindowRef(popupWindow, 'callback_processed');
            })
            .catch((error) => {
              closePopupWindowRef(popupWindow, 'callback_error');
              applyError(error, 'No se pudo procesar callback automatico.');
            })
            .finally(() => {
              clearPopupWatcher();
            });
        }, 700);
      }

      function getTopLocationHref() {
        try {
          if (window.top && window.top.location && window.top.location.href) {
            return String(window.top.location.href);
          }
        } catch (_e) {
          // ignore and fallback below
        }
        if (document.referrer) {
          return String(document.referrer);
        }
        try {
          return String(window.location.href || '');
        } catch (_e) {
          return '';
        }
      }

      function deriveDefaultRedirectUri() {
        const href = getTopLocationHref();
        if (!href) return '';
        try {
          const url = new URL(href);
          url.search = '';
          url.hash = '';
          return url.toString();
        } catch (_e) {
          return '';
        }
      }

      function clearOAuthParamsFromTopUrl() {
        const href = getTopLocationHref();
        try {
          const url = new URL(href);
          ['code', 'state', 'error', 'error_description'].forEach((key) => url.searchParams.delete(key));
          const clean = url.toString();
          try {
            if (window.top && window.top.history && typeof window.top.history.replaceState === 'function') {
              window.top.history.replaceState({}, '', clean);
              return;
            }
          } catch (_eTop) {
            // ignore
          }
          window.history.replaceState({}, '', clean);
        } catch (_e) {
          // ignore
        }
      }

      function navigateTop(urlValue, popupWindow) {
        const target = String(urlValue || '');
        if (!target) return;
        dbg('oauth_navigate_attempt', { target_host: safeHostname(target), has_popup: !!popupWindow });
        if (popupWindow && !popupWindow.closed) {
          try {
            popupWindow.location.href = target;
            if (typeof popupWindow.focus === 'function') {
              popupWindow.focus();
            }
            dbg('oauth_navigate_popup_success');
            return;
          } catch (error) {
            dbg('oauth_navigate_popup_failed', { message: error && error.message ? error.message : String(error) });
          }
        }
        try {
          const popup = window.open(target, '_blank');
          if (popup) {
            dbg('oauth_navigate_window_open_success');
            return;
          }
          dbg('oauth_navigate_window_open_blocked');
        } catch (error) {
          dbg('oauth_navigate_window_open_failed', { message: error && error.message ? error.message : String(error) });
        }
        try {
          if (window.top && window.top.location) {
            window.top.location.href = target;
            dbg('oauth_navigate_top_success');
            return;
          }
        } catch (error) {
          dbg('oauth_navigate_top_failed', { message: error && error.message ? error.message : String(error) });
        }
        try {
          window.location.href = target;
          dbg('oauth_navigate_iframe_success');
        } catch (error) {
          dbg('oauth_navigate_iframe_failed', { message: error && error.message ? error.message : String(error) });
          showMsg('error', 'No se pudo abrir la autorizacion OAuth. Permite ventanas emergentes y usa nueva pestana.');
        }
      }

      function adfToText(node) {
        if (!node) return '';
        if (typeof node === 'string') return node;
        if (Array.isArray(node)) return node.map(adfToText).join('');
        if (node.type === 'text') return node.text || '';
        if (node.type === 'hardBreak') return '\n';
        if (Array.isArray(node.content)) return node.content.map(adfToText).join('');
        return '';
      }

      function toAdf(text) {
        return {
          type: 'doc', version: 1,
          content: [{ type: 'paragraph', content: [{ type: 'text', text: String(text || '') }] }]
        };
      }

      function escapeHtml(v) {
        return String(v || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      function httpMessage(payload, status) {
        if (payload && typeof payload.error_description === 'string' && payload.error_description) {
          const errCode = typeof payload.error === 'string' && payload.error ? payload.error : 'oauth_error';
          return `${errCode}: ${payload.error_description}`;
        }
        if (payload && typeof payload.error === 'string' && payload.error) {
          return payload.error;
        }
        if (payload && Array.isArray(payload.errorMessages) && payload.errorMessages.length) return payload.errorMessages.join(' | ');
        if (payload && payload.errors && typeof payload.errors === 'object') {
          const items = Object.entries(payload.errors).map(([k, v]) => `${k}: ${v}`);
          if (items.length) return items.join(' | ');
        }
        if (payload && payload.message) return payload.message;
        return `HTTP ${status}`;
      }
      function cacheElements() {
        [
          'connPill','userPill','refreshIssuesBtn','disconnectBtn','msg','idleMsg',
          'debugLogBox','debugCopyBtn','debugClearBtn',
          'loginView','urlInp','clientIdInp','clientSecretInp','redirectUriInp','callbackUrlInp','connectBtn','processCallbackBtn','clearOAuthBtn',
          'mainView','issueSel','activityTypeSel','activityDueInp','activityInp','minutesInp','registerBtn','jiraDurationPill','timerVal','timerState','startBtn','pauseBtn',
          'resetBtn','applyTimerBtn','suggestionBox','applySugActBtn','applySugTimeBtn','registerSugBtn','todayTotal','weekTotal','issueCount','dashMeta',
          'refreshDashBtn','recentBox','commentsBox','worklogBody','timelineBox','ganttBox','genReportBtn','exportReportBtn','reportMeta',
          'reportBody','timelinePanel','chartDesignSel','chartDesignHelp','activityFocusBox','activityQuickSel','activityQuickMeta','compactBtn','floatBox','floatIssue','floatTimer','floatState','floatStartBtn','floatPauseBtn','floatExpandBtn',
          'regInlineBox','regInlineMeta','regTypeSel','regDateInp','regMinInp','regInlineOkBtn','regInlineCancelBtn',
          'editInlineBox','editMeta','editTypeSel','editActInp','editDateInp','editTimeInp','editMinInp','editSaveBtn','editDeleteBtn','editCancelBtn','activityList'
        ].forEach((id) => { el[id] = document.getElementById(id); });
      }

      function uiStateSave() {
        StorageService.saveUI({
          selectedIssueKey: state.selectedIssueKey,
          activity: state.activity,
          activityType: state.activityType,
          activityDueDate: state.activityDueDate,
          durationMinutes: state.durationMinutes,
          compact: state.compact,
          chartDesign: state.chartDesign,
          lastReminderTs: state.lastReminderTs
        });
      }

      function uiStateLoad() {
        const ui = StorageService.getUI();
        state.selectedIssueKey = typeof ui.selectedIssueKey === 'string' ? ui.selectedIssueKey : '';
        state.activity = typeof ui.activity === 'string' ? ui.activity : '';
        state.activityType = OFFICIAL_ACTIVITY_TYPES.includes(String(ui.activityType || '').trim())
          ? String(ui.activityType || '').trim()
          : OFFICIAL_ACTIVITY_TYPES[0];
        state.activityDueDate = isValidInputDate(ui.activityDueDate)
          ? String(ui.activityDueDate)
          : TimeService.toInputDate(new Date());
        const parsed = parseOfficialActivity(state.activity);
        if (parsed) {
          state.activityType = parsed.type;
          state.activityDueDate = parsed.dueInput;
        } else {
          state.activity = buildOfficialActivity(state.activityType, state.activityDueDate);
        }
        state.durationMinutes = Number.isFinite(Number(ui.durationMinutes)) ? Math.max(1, Math.floor(Number(ui.durationMinutes))) : 30;
        state.compact = !!ui.compact;
        state.chartDesign = CHART_DESIGNS.some((d) => d.id === String(ui.chartDesign || '').trim())
          ? String(ui.chartDesign || '').trim()
          : DEFAULT_CHART_DESIGN;
        state.lastReminderTs = Number(ui.lastReminderTs || 0);
        state.lastActivityTs = StorageService.getLastActivity();
        state.activities = StorageService.getActivities();
      }

      function timerLoad() {
        const t = StorageService.getTimer();
        if (!t) return;
        state.timer.running = !!t.running;
        state.timer.resumeTs = Number(t.resumeTs || 0);
        state.timer.elapsedBizMs = Number(t.elapsedBizMs || 0);
        if (state.timer.running && !state.timer.resumeTs) state.timer.running = false;
      }

      function timerSave() { StorageService.saveTimer(state.timer); }

      function showMsg(type, text) {
        el.msg.className = `msg show ${type}`;
        el.msg.textContent = text;
      }

      function clearMsg() {
        el.msg.className = 'msg';
        el.msg.textContent = '';
      }

      function applyError(err, fallback) {
        dbg('error', {
          fallback,
          kind: err && err.kind ? err.kind : '',
          status: err && err.status ? err.status : '',
          message: err && err.message ? err.message : ''
        });
        if (err && err.kind === 'cors') {
          showMsg('error', 'No se pudo conectar a Jira desde frontend por limitacion CORS del tenant Jira Cloud.');
          return;
        }
        if (err && err.kind === 'oauth' && err.status === 400) {
          showMsg('error', `OAuth invalido. Revisa Client ID, Client Secret, Redirect URI y PKCE en Atlassian.${err && err.message ? ` Detalle: ${err.message}` : ''}`);
          return;
        }
        if (err && err.kind === 'oauth' && err.status === 401) {
          showMsg('error', `Sesion OAuth expirada o invalida. Verifica Client Secret y reconecta.${err && err.message ? ` Detalle: ${err.message}` : ''}`);
          return;
        }
        if (err && err.kind === 'http' && err.status === 401) {
          showMsg('error', 'Sesion expirada o autorizacion invalida en Jira. Reconecta con OAuth.');
          return;
        }
        if (err && err.kind === 'http' && err.status === 403) {
          showMsg('error', 'No tienes permisos suficientes en Jira para esta accion.');
          return;
        }
        showMsg('error', `${fallback}${err && err.message ? ` Detalle: ${err.message}` : ''}`);
      }

      function markActivity() {
        state.lastActivityTs = Date.now();
        state.lastReminderTs = 0;
        StorageService.saveLastActivity(state.lastActivityTs);
        uiStateSave();
      }

      function renderIdle() {
        const idle = !state.timer.running && (Date.now() - state.lastActivityTs >= INACTIVITY_MS);
        if (idle) {
          el.idleMsg.className = 'msg show info';
          el.idleMsg.textContent = 'Aviso: pasaron mas de 2 horas sin actividad registrada y el timer esta detenido.';
        } else {
          el.idleMsg.className = 'msg';
          el.idleMsg.textContent = '';
        }
      }

      function renderTop() {
        el.connPill.textContent = state.connected ? 'Conectado' : 'Sin conexion';
        el.connPill.className = `pill ${state.connected ? 'ok' : ''}`;
        el.userPill.textContent = state.connected
          ? `Usuario: ${state.me && state.me.displayName ? state.me.displayName : (state.config && state.config.url ? state.config.url : '-')}`
          : 'Usuario: -';
        el.disconnectBtn.disabled = !state.connected;
        el.refreshIssuesBtn.disabled = !state.connected;
        el.loginView.classList.toggle('hide', state.connected);
        el.mainView.classList.toggle('hide', !state.connected);
      }

      function renderActivitiesList() {
        el.activityList.innerHTML = '';
        state.activities.slice(0, 30).forEach((item) => {
          const opt = document.createElement('option');
          opt.value = item;
          el.activityList.appendChild(opt);
        });
      }

      function syncOfficialActivityToState(saveUi = true) {
        state.activityType = OFFICIAL_ACTIVITY_TYPES.includes(String(el.activityTypeSel.value || '').trim())
          ? String(el.activityTypeSel.value || '').trim()
          : OFFICIAL_ACTIVITY_TYPES[0];
        state.activityDueDate = isValidInputDate(el.activityDueInp.value)
          ? String(el.activityDueInp.value)
          : TimeService.toInputDate(new Date());
        el.activityDueInp.value = state.activityDueDate;
        state.activity = buildOfficialActivity(state.activityType, state.activityDueDate);
        el.activityInp.value = state.activity;
        if (el.activityQuickSel && el.activityQuickSel.options.length) {
          el.activityQuickSel.value = state.activityType;
        }
        if (saveUi) {
          uiStateSave();
        }
      }

      function renderOfficialActivityControls() {
        const optionsHtml = OFFICIAL_ACTIVITY_TYPES
          .map((name) => `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`)
          .join('');
        el.activityTypeSel.innerHTML = optionsHtml;
        if (el.regTypeSel) {
          el.regTypeSel.innerHTML = optionsHtml;
        }
        if (el.editTypeSel) {
          el.editTypeSel.innerHTML = optionsHtml;
        }
        if (!OFFICIAL_ACTIVITY_TYPES.includes(state.activityType)) {
          state.activityType = OFFICIAL_ACTIVITY_TYPES[0];
        }
        if (!isValidInputDate(state.activityDueDate)) {
          state.activityDueDate = TimeService.toInputDate(new Date());
        }
        el.activityTypeSel.value = state.activityType;
        el.activityDueInp.value = state.activityDueDate;
        if (el.regTypeSel && el.regTypeSel.options.length && !OFFICIAL_ACTIVITY_TYPES.includes(String(el.regTypeSel.value || '').trim())) {
          el.regTypeSel.value = state.activityType;
        }
        if (el.regDateInp && !isValidInputDate(el.regDateInp.value)) {
          el.regDateInp.value = state.activityDueDate;
        }
        if (el.editTypeSel && el.editTypeSel.options.length && !OFFICIAL_ACTIVITY_TYPES.includes(String(el.editTypeSel.value || '').trim())) {
          el.editTypeSel.value = state.activityType;
        }
        if (el.editDateInp && !isValidInputDate(el.editDateInp.value)) {
          el.editDateInp.value = state.activityDueDate;
        }
        syncEditActivityPreview();
        syncOfficialActivityToState(false);
      }

      function syncInlineRegistrarInputs() {
        if (!el.regTypeSel || !el.regDateInp) return;
        const selectedType = OFFICIAL_ACTIVITY_TYPES.includes(String(el.regTypeSel.value || '').trim())
          ? String(el.regTypeSel.value || '').trim()
          : OFFICIAL_ACTIVITY_TYPES[0];
        const dueDate = isValidInputDate(el.regDateInp.value)
          ? String(el.regDateInp.value)
          : TimeService.toInputDate(new Date());
        el.regTypeSel.value = selectedType;
        el.regDateInp.value = dueDate;
      }

      function hideInlineRegistrar() {
        state.regCtx = null;
        if (el.regInlineBox) {
          el.regInlineBox.classList.add('hide');
        }
      }

      function showInlineRegistrar() {
        if (el.regInlineBox) {
          el.regInlineBox.classList.remove('hide');
          if (typeof el.regInlineBox.scrollIntoView === 'function') {
            el.regInlineBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
      }

      function syncEditActivityPreview() {
        if (!el.editTypeSel || !el.editActInp || !el.editDateInp) return;
        const selectedType = OFFICIAL_ACTIVITY_TYPES.includes(String(el.editTypeSel.value || '').trim())
          ? String(el.editTypeSel.value || '').trim()
          : OFFICIAL_ACTIVITY_TYPES[0];
        const dueDate = isValidInputDate(el.editDateInp.value)
          ? String(el.editDateInp.value)
          : TimeService.toInputDate(new Date());
        el.editTypeSel.value = selectedType;
        el.editDateInp.value = dueDate;
        el.editActInp.value = buildOfficialActivity(selectedType, dueDate);
      }

      function hideInlineEditor() {
        state.editCtx = null;
        if (el.editInlineBox) {
          el.editInlineBox.classList.add('hide');
        }
      }

      function showInlineEditor() {
        if (el.editInlineBox) {
          el.editInlineBox.classList.remove('hide');
          if (typeof el.editInlineBox.scrollIntoView === 'function') {
            el.editInlineBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
      }

      function activityKey(text) {
        return String(text || '').trim().toLowerCase();
      }

      function syncActivityFocusComponent() {
        if (!el.activityQuickSel) return;
        if (!el.activityQuickSel.options.length) {
          el.activityQuickSel.innerHTML = OFFICIAL_ACTIVITY_TYPES
            .map((name) => `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`)
            .join('');
        }
        if (!OFFICIAL_ACTIVITY_TYPES.includes(state.activityType)) {
          state.activityType = OFFICIAL_ACTIVITY_TYPES[0];
        }
        el.activityQuickSel.value = state.activityType;

        const selected = String(state.selectedTimelineActivity || '').trim();
        const mins = Number(state.selectedTimelineMinutes || 0);
        if (!selected) {
          el.activityFocusBox.classList.remove('active');
          el.activityQuickMeta.textContent = 'Haz clic en una actividad del grafico para resaltarla aqui.';
          return;
        }
        const duration = mins > 0 ? ` | ${TimeService.jiraDuration(mins)}` : '';
        el.activityFocusBox.classList.add('active');
        el.activityQuickMeta.innerHTML = `Actividad resaltada: <strong>${escapeHtml(selected)}</strong>${escapeHtml(duration)}`;
      }

      function applyChartDesign() {
        const valid = CHART_DESIGNS.some((d) => d.id === state.chartDesign);
        if (!valid) {
          state.chartDesign = DEFAULT_CHART_DESIGN;
        }
        const current = CHART_DESIGNS.find((d) => d.id === state.chartDesign) || CHART_DESIGNS[0];
        if (el.chartDesignSel) {
          if (!el.chartDesignSel.options.length) {
            el.chartDesignSel.innerHTML = CHART_DESIGNS
              .map((d) => `<option value="${escapeHtml(d.id)}">${escapeHtml(d.label)}</option>`)
              .join('');
          }
          el.chartDesignSel.value = state.chartDesign;
        }
        if (el.chartDesignHelp) {
          el.chartDesignHelp.textContent = current && current.help ? current.help : '';
        }
      }

      function selectActivityFromCharts(activityName, minutes, rerender) {
        const activity = String(activityName || '').trim();
        if (!activity) return;
        state.selectedTimelineActivity = activity;
        if (Number.isFinite(Number(minutes))) {
          state.selectedTimelineMinutes = Math.max(0, Math.floor(Number(minutes)));
        }
        const official = inferOfficialActivityType(activity);
        if (OFFICIAL_ACTIVITY_TYPES.includes(official)) {
          state.activityType = official;
          el.activityTypeSel.value = state.activityType;
          syncOfficialActivityToState(true);
        }
        syncActivityFocusComponent();
        if (rerender) {
          renderTimeline(state.selectedIssueKey);
        }
      }

      function pushActivity(act) {
        const value = String(act || '').trim();
        if (!value) return;
        const list = [value, ...state.activities.filter((x) => x.toLowerCase() !== value.toLowerCase())].slice(0, 100);
        state.activities = list;
        StorageService.saveActivities(list);
        renderActivitiesList();
      }

      function issueByKey(key) {
        return state.issues.find((it) => it.key === key) || null;
      }

      function parseIssues(payload) {
        const list = Array.isArray(payload.issues)
          ? payload.issues
          : (Array.isArray(payload.values) ? payload.values : []);
        return list
          .filter((it) => it && it.key && it.fields && !(it.fields.issuetype && it.fields.issuetype.subtask))
          .map((it) => ({
            key: it.key,
            summary: String(it.fields.summary || ''),
            attachments: Array.isArray(it.fields.attachment) ? it.fields.attachment : []
          }));
      }

      function renderIssueSelect() {
        el.issueSel.innerHTML = '';
        if (!state.issues.length) {
          el.issueSel.innerHTML = '<option value="">Sin tickets</option>';
          state.selectedIssueKey = '';
          uiStateSave();
          renderIssueData();
          return;
        }
        state.issues.forEach((it) => {
          const opt = document.createElement('option');
          opt.value = it.key;
          opt.textContent = `${it.key} - ${it.summary}`;
          el.issueSel.appendChild(opt);
        });
        if (!state.issues.some((it) => it.key === state.selectedIssueKey)) {
          state.selectedIssueKey = state.issues[0].key;
        }
        el.issueSel.value = state.selectedIssueKey;
        uiStateSave();
      }

      function timerBusinessMsNow() {
        let total = state.timer.elapsedBizMs;
        if (state.timer.running) {
          total += TimeService.businessMsBetween(new Date(state.timer.resumeTs), new Date());
        }
        return total;
      }

      function timerStateLabel() {
        if (!state.timer.running) return 'inactivo';
        return TimeService.isBusinessNow(new Date()) ? 'en curso' : 'en curso fuera de horario';
      }

      function renderTimer() {
        const ms = timerBusinessMsNow();
        const label = timerStateLabel();
        const value = TimeService.hhmmss(ms);
        el.timerVal.textContent = value;
        el.timerState.textContent = `Estado: ${label}`;
        el.floatTimer.textContent = value;
        el.floatState.textContent = `Estado: ${label}`;
      }

      function timerStart() {
        if (state.timer.running) return;
        state.timer.running = true;
        state.timer.resumeTs = Date.now();
        timerSave();
        markActivity();
        renderTimer();
      }

      function timerPause() {
        if (!state.timer.running) return;
        state.timer.elapsedBizMs += TimeService.businessMsBetween(new Date(state.timer.resumeTs), new Date());
        state.timer.running = false;
        state.timer.resumeTs = 0;
        timerSave();
        markActivity();
        renderTimer();
      }

      function timerReset() {
        state.timer.running = false;
        state.timer.resumeTs = 0;
        state.timer.elapsedBizMs = 0;
        timerSave();
        markActivity();
        renderTimer();
      }

      function applyTimerToMinutes() {
        const mins = Math.max(1, Math.ceil(timerBusinessMsNow() / 60000));
        state.durationMinutes = mins;
        el.minutesInp.value = String(mins);
        renderDurationPill();
        uiStateSave();
      }

      function renderDurationPill() {
        const mins = Math.max(1, Math.floor(Number(state.durationMinutes || 0)));
        el.jiraDurationPill.textContent = TimeService.jiraDuration(mins);
      }

      function renderCompact() {
        el.floatIssue.textContent = state.selectedIssueKey || '-';
        el.floatBox.classList.toggle('show', state.connected && state.compact);
        el.compactBtn.textContent = state.compact ? 'Expandir vista' : 'Modo compacto';
      }

      function commentText(c) { return adfToText(c && c.body ? c.body : ''); }
      function worklogText(w) { return adfToText(w && w.comment ? w.comment : ''); }
      function mine(author) { return !!(author && state.me && String(author.accountId || '') === String(state.me.accountId || '')); }
      function minutesOf(worklog) { return Math.max(1, Math.round(Number(worklog && worklog.timeSpentSeconds ? worklog.timeSpentSeconds : 0) / 60)); }

      function activityFromText(text) {
        const t = String(text || '').trim();
        if (!t) return '';
        const m = t.match(/^\[([^\]]+)\]/);
        if (m && m[1]) return m[1].trim();
        return (t.split(/\r?\n/)[0] || '').trim().slice(0, 80);
      }

      function activityOf(worklog) {
        return activityFromText(worklogText(worklog)) || 'Sin actividad';
      }

      function normalizePlain(text) {
        return String(text || '')
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '')
          .toLowerCase();
      }

      function inferOfficialActivityType(sourceText) {
        const normalized = normalizePlain(sourceText);
        for (const name of OFFICIAL_ACTIVITY_TYPES) {
          const n = normalizePlain(name);
          if (normalized.includes(n)) return name;
        }
        if (normalized.includes('agente') && normalized.includes('exito')) return 'Configuración Agente de Éxito';
        if (normalized.includes('estandarizacion') && normalized.includes('plantilla')) return 'Estandarización de plantillas';
        if (normalized.includes('docente') && normalized.includes('plantilla')) return 'Entrega de plantillas DOCENTES Coach/Farmer/Hunter';
        if (normalized.includes('estudiante') && normalized.includes('plantilla')) return 'Entrega de plantillas ESTUDIANTES Coach/Farmer/Hunter';
        if (normalized.includes('pendiente')) return 'Pendiente información';
        if (normalized.includes('integracion') && normalized.includes('lql')) return 'Integración LQL';
        if (normalized.includes('integracion') && normalized.includes('rlp')) return 'Integración RLP';
        if (normalized.includes('integracion') && normalized.includes('ldb')) return 'Integración LDB';
        if (normalized.includes('integracion') && normalized.includes('wemath')) return 'Integración WeMath';
        if (normalized.includes('integracion') && normalized.includes('pleno')) return 'Integración Pleno';
        if (normalized.includes('integracion') && normalized.includes('studio')) return 'Integración Studio';
        if (normalized.includes('configuracion') && normalized.includes('colegio')) return 'Configuración de colegio';
        if (normalized.includes('configuracion') && normalized.includes('docente')) return 'Configuración de docentes';
        if (normalized.includes('configuracion') && normalized.includes('estudiante')) return 'Configuración de estudiantes';
        return OFFICIAL_ACTIVITY_TYPES[0];
      }

      function sortDesc(items, dateFn) {
        return items.slice().sort((a, b) => new Date(dateFn(b)).getTime() - new Date(dateFn(a)).getTime());
      }

      function renderComments(issueKey) {
        const comments = state.commentsByIssue[issueKey] || [];
        if (!comments.length) {
          state.selectedCommentId = '';
          hideInlineRegistrar();
          el.commentsBox.innerHTML = '<div class="empty">Sin comentarios.</div>';
          return;
        }
        el.commentsBox.innerHTML = comments.map((c) => {
          const my = mine(c.author);
          const id = String(c.id || '');
          const selectedClass = state.selectedCommentId && String(state.selectedCommentId) === id ? ' selected' : '';
          const author = c.author && c.author.displayName ? c.author.displayName : 'Sin autor';
          const txt = commentText(c) || '(sin texto)';
          return `
            <div class="comment ${my ? 'mine' : ''}${selectedClass}" data-comment-id="${escapeHtml(id)}">
              <div class="meta"><span>${escapeHtml(author)}</span><span>${escapeHtml(TimeService.dtLabel(c.created))}</span></div>
              <div class="body">${escapeHtml(txt)}</div>
              <div class="row" style="margin-top:8px;"><button class="btn" data-act="reg-from-comment" data-id="${escapeHtml(id)}">Registrar actividad</button></div>
            </div>
          `;
        }).join('');
      }
      function renderWorklogs(issueKey) {
        const rows = state.worklogsByIssue[issueKey] || [];
        if (!rows.length) {
          state.selectedWorklogId = '';
          el.worklogBody.innerHTML = '<tr><td colspan="4"><div class="empty">Sin worklogs.</div></td></tr>';
          return;
        }
        el.worklogBody.innerHTML = rows.map((w) => {
          const my = mine(w.author);
          const id = String(w.id || '');
          const date = TimeService.dtLabel(w.started || w.created || new Date());
          const act = activityOf(w);
          const mins = TimeService.jiraDuration(minutesOf(w));
          const actions = my
            ? `<button class="btn" data-act="view-worklog" data-id="${escapeHtml(id)}">Ver dashboard</button> <button class="btn" data-act="edit-worklog" data-id="${escapeHtml(id)}">Editar</button> <button class="btn danger" data-act="del-worklog" data-id="${escapeHtml(id)}">Eliminar</button>`
            : `<button class="btn" data-act="view-worklog" data-id="${escapeHtml(id)}">Ver dashboard</button> <span class="pill">Solo lectura</span>`;
          const selectedClass = state.selectedWorklogId && String(state.selectedWorklogId) === id ? ' selected' : '';
          return `<tr class="worklog-row${selectedClass}" data-worklog-id="${escapeHtml(id)}"><td>${escapeHtml(date)}</td><td>${escapeHtml(act)}</td><td>${escapeHtml(mins)}</td><td>${actions}</td></tr>`;
        }).join('');
      }

      function focusWorklogInDashboard(issueKey, worklog) {
        if (!worklog) return;
        const worklogId = String(worklog.id || '');
        const links = state.timelineLinksByIssue[issueKey] || { worklogToCommentId: {} };
        const commentId = links.worklogToCommentId && links.worklogToCommentId[worklogId]
          ? String(links.worklogToCommentId[worklogId])
          : '';
        state.selectedCommentId = commentId;
        state.selectedWorklogId = worklogId;
        selectActivityFromCharts(activityOf(worklog), minutesOf(worklog), false);
        renderComments(issueKey);
        renderWorklogs(issueKey);
        renderTimeline(issueKey);
        if (state.selectedCommentId) {
          const commentEl = el.commentsBox.querySelector(`.comment[data-comment-id="${String(state.selectedCommentId)}"]`);
          if (commentEl && typeof commentEl.scrollIntoView === 'function') {
            commentEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
        if (el.timelinePanel && typeof el.timelinePanel.scrollIntoView === 'function') {
          el.timelinePanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        showMsg('info', 'Registro enfocado en el dashboard.');
      }

      function suggestionFor(issueKey) {
        const comments = state.commentsByIssue[issueKey] || [];
        const worklogs = state.worklogsByIssue[issueKey] || [];
        if (!comments.length || !state.me) return null;
        const commentsAsc = comments
          .slice()
          .filter((c) => c && c.created)
          .sort((a, b) => new Date(a.created).getTime() - new Date(b.created).getTime());
        const myLogs = worklogs
          .slice()
          .filter((w) => mine(w.author))
          .sort((a, b) => new Date(a.started || a.created || 0).getTime() - new Date(b.started || b.created || 0).getTime());
        const pending = [];
        for (let i = 0; i < commentsAsc.length; i += 1) {
          const c = commentsAsc[i];
          const cTs = new Date(c.created).getTime();
          const nextTs = i < commentsAsc.length - 1
            ? new Date(commentsAsc[i + 1].created).getTime()
            : Number.POSITIVE_INFINITY;
          if (!Number.isFinite(cTs)) continue;
          const registered = myLogs.some((w) => {
            const wTs = new Date(w.started || w.created || 0).getTime();
            return Number.isFinite(wTs) && wTs >= cTs && wTs < nextTs;
          });
          if (!registered) {
            pending.push(c);
          }
        }
        if (pending.length) {
          const c = pending[pending.length - 1];
          const suggestedType = inferOfficialActivityType(commentText(c));
          const mins = Math.max(5, Math.min(480, TimeService.businessMinutesBetween(new Date(c.created), new Date())));
          return {
            commentId: c.id,
            created: c.created,
            author: c.author && c.author.displayName ? c.author.displayName : 'Sin autor',
            activity: suggestedType,
            activityType: suggestedType,
            minutes: mins
          };
        }
        return null;
      }

      function renderSuggestion(issueKey) {
        state.suggestion = suggestionFor(issueKey);
        if (!state.suggestion) {
          el.suggestionBox.className = 'empty';
          el.suggestionBox.textContent = 'No hay sugerencias pendientes.';
          el.applySugActBtn.disabled = true;
          el.applySugTimeBtn.disabled = true;
          el.registerSugBtn.disabled = true;
          return;
        }
        const s = state.suggestion;
        el.suggestionBox.className = 'msg show info';
        el.suggestionBox.innerHTML = `Comentario pendiente detectado.<br>Autor: <strong>${escapeHtml(s.author || 'Sin autor')}</strong><br>Actividad sugerida: <strong>${escapeHtml(s.activity)}</strong><br>Tiempo: <strong>${escapeHtml(TimeService.jiraDuration(s.minutes))}</strong><br>Fecha comentario: ${escapeHtml(TimeService.dtLabel(s.created))}`;
        el.applySugActBtn.disabled = false;
        el.applySugTimeBtn.disabled = false;
        el.registerSugBtn.disabled = false;
      }

      function weekStartTs(ts) {
        const d = new Date(ts);
        const day = (d.getDay() + 6) % 7;
        d.setHours(0, 0, 0, 0);
        d.setDate(d.getDate() - day);
        return d.getTime();
      }

      function buildCommentWorklogLinks(commentsAsc, logsAsc) {
        const commentToWorklogIds = {};
        const worklogToCommentId = {};
        for (let i = 0; i < commentsAsc.length; i += 1) {
          const c = commentsAsc[i];
          const cId = String(c.id || '');
          const cTs = new Date(c.created || 0).getTime();
          const nextTs = i < commentsAsc.length - 1
            ? new Date(commentsAsc[i + 1].created || 0).getTime()
            : Number.POSITIVE_INFINITY;
          const matched = [];
          if (Number.isFinite(cTs)) {
            logsAsc.forEach((r) => {
              const ts = Number(r.startTs || 0);
              if (!Number.isFinite(ts)) return;
              if (ts >= cTs && ts < nextTs) {
                matched.push(r.id);
                if (!worklogToCommentId[r.id]) worklogToCommentId[r.id] = cId;
              }
            });
          }
          commentToWorklogIds[cId] = matched;
        }
        return { commentToWorklogIds, worklogToCommentId };
      }

      function buildContinuousTimelineData(issueKey) {
        const commentsAsc = sortDesc((state.commentsByIssue[issueKey] || []).slice(), (x) => x.created || '').reverse();
        const logsAsc = sortDesc((state.worklogsByIssue[issueKey] || []).slice(), (x) => x.started || x.created || '').reverse()
          .map((w) => {
            const startTs = new Date(w.started || w.created).getTime();
            const mins = minutesOf(w);
            const endTs = startTs + Math.max(60000, mins * 60000);
            const activity = activityOf(w) || 'Sin actividad';
            return {
              id: String(w.id || ''),
              worklog: w,
              startTs,
              endTs,
              mins,
              activity,
              color: activityColor(activity),
              author: w.author && w.author.displayName ? w.author.displayName : 'Sin autor'
            };
          })
          .filter((r) => Number.isFinite(r.startTs) && Number.isFinite(r.endTs));

        if (!commentsAsc.length && !logsAsc.length) return null;

        const startCandidates = [];
        const endCandidates = [];
        logsAsc.forEach((r) => {
          startCandidates.push(r.startTs);
          endCandidates.push(r.endTs);
        });
        commentsAsc.forEach((c) => {
          const ts = new Date(c.created || 0).getTime();
          if (!Number.isFinite(ts)) return;
          startCandidates.push(ts);
          endCandidates.push(ts + 60000);
        });

        let start = Math.min(...startCandidates);
        let end = Math.max(...endCandidates);
        if (!Number.isFinite(start) || !Number.isFinite(end)) {
          start = Date.now() - 3600000;
          end = Date.now();
        }
        if (end <= start) end = start + 3600000;
        const range = Math.max(60000, end - start);

        const links = buildCommentWorklogLinks(commentsAsc, logsAsc);
        const lanesMap = {};
        logsAsc.forEach((r) => {
          if (!lanesMap[r.activity]) {
            lanesMap[r.activity] = { activity: r.activity, color: r.color, totalMinutes: 0, items: [] };
          }
          const linkedCommentId = links.worklogToCommentId[r.id] || '';
          lanesMap[r.activity].items.push(Object.assign({}, r, { linkedCommentId }));
          lanesMap[r.activity].totalMinutes += r.mins;
        });
        const lanes = Object.values(lanesMap).sort((a, b) => b.totalMinutes - a.totalMinutes || a.activity.localeCompare(b.activity));
        const totalMinutes = logsAsc.reduce((acc, r) => acc + r.mins, 0);
        const commentsWithWorklog = commentsAsc.filter((c) => (links.commentToWorklogIds[String(c.id || '')] || []).length > 0).length;

        return { issueKey, start, end, range, commentsAsc, logsAsc, lanes, totalMinutes, commentsWithWorklog, links };
      }

      function focusTimelineSelection(issueKey, commentId, worklogId, activity, minutes) {
        if (!issueKey) return;
        state.selectedCommentId = commentId ? String(commentId) : '';
        state.selectedWorklogId = worklogId ? String(worklogId) : '';
        if (activity) {
          state.selectedTimelineActivity = String(activity);
          if (Number.isFinite(Number(minutes))) {
            state.selectedTimelineMinutes = Math.max(0, Math.floor(Number(minutes)));
          }
          const official = inferOfficialActivityType(activity);
          if (OFFICIAL_ACTIVITY_TYPES.includes(official)) {
            state.activityType = official;
            el.activityTypeSel.value = state.activityType;
            syncOfficialActivityToState(true);
          } else {
            syncActivityFocusComponent();
          }
        }
        renderComments(issueKey);
        renderWorklogs(issueKey);
        renderTimeline(issueKey);
        if (state.selectedCommentId) {
          const commentEl = el.commentsBox.querySelector(`.comment[data-comment-id="${String(state.selectedCommentId)}"]`);
          if (commentEl && typeof commentEl.scrollIntoView === 'function') {
            commentEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
        if (state.selectedWorklogId) {
          const worklogEl = el.worklogBody.querySelector(`tr[data-worklog-id="${String(state.selectedWorklogId)}"]`);
          if (worklogEl && typeof worklogEl.scrollIntoView === 'function') {
            worklogEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
      }

      function renderTimeline(issueKey) {
        const key = String(issueKey || '').trim();
        if (!key) {
          state.selectedTimelineActivity = '';
          state.selectedTimelineMinutes = 0;
          state.timelineLinksByIssue[key] = { commentToWorklogIds: {}, worklogToCommentId: {} };
          el.timelineBox.className = 'empty';
          el.timelineBox.textContent = 'Sin ticket seleccionado.';
          el.ganttBox.className = 'hide';
          el.ganttBox.innerHTML = '';
          syncActivityFocusComponent();
          return;
        }

        const data = buildContinuousTimelineData(key);
        if (!data) {
          state.selectedTimelineActivity = '';
          state.selectedTimelineMinutes = 0;
          state.timelineLinksByIssue[key] = { commentToWorklogIds: {}, worklogToCommentId: {} };
          el.timelineBox.className = 'empty';
          el.timelineBox.textContent = 'Sin comentarios ni worklogs para este ticket.';
          el.ganttBox.className = 'hide';
          el.ganttBox.innerHTML = '';
          syncActivityFocusComponent();
          return;
        }

        state.timelineLinksByIssue[key] = data.links;
        if (state.selectedWorklogId && !data.logsAsc.some((r) => r.id === String(state.selectedWorklogId))) {
          state.selectedWorklogId = '';
        }
        if (state.selectedCommentId && !data.commentsAsc.some((c) => String(c.id || '') === String(state.selectedCommentId))) {
          state.selectedCommentId = '';
        }

        const selectedActivityKey = activityKey(state.selectedTimelineActivity);
        const selectedLane = data.lanes.find((l) => activityKey(l.activity) === selectedActivityKey) || null;
        if (!selectedLane) {
          state.selectedTimelineActivity = '';
          state.selectedTimelineMinutes = 0;
        } else {
          state.selectedTimelineMinutes = selectedLane.totalMinutes;
        }

        const metaHtml = '';

        const commentLaneDots = data.commentsAsc.map((c) => {
          const cId = String(c.id || '');
          const cTs = new Date(c.created || 0).getTime();
          if (!Number.isFinite(cTs)) return '';
          const left = ((cTs - data.start) / data.range) * 100;
          const linked = data.links.commentToWorklogIds[cId] || [];
          const linkedWorklogId = linked.length ? String(linked[0]) : '';
          const statusClass = linked.length ? 'matched' : 'missing';
          const active = state.selectedCommentId && String(state.selectedCommentId) === cId ? ' active' : '';
          const title = linked.length ? `Comentario con ${linked.length} worklog(s)` : 'Comentario sin worklog relacionado';
          return `<span class="timeline-comment-dot ${statusClass}${active}" style="left:${left.toFixed(3)}%;" data-comment-id="${escapeHtml(cId)}" data-worklog-id="${escapeHtml(linkedWorklogId)}" title="${escapeHtml(title)}"></span>`;
        }).join('');

        const commentLane = `
          <div class="timeline-lane comments-only">
            <div class="timeline-lane-track">${commentLaneDots}</div>
          </div>
        `;

        const activityLanes = data.lanes.map((lane) => {
          const laneSelected = selectedActivityKey && activityKey(lane.activity) === selectedActivityKey;
          const bars = lane.items.map((r) => {
            const left = ((r.startTs - data.start) / data.range) * 100;
            const width = Math.max(1.8, ((r.endTs - r.startTs) / data.range) * 100);
            const active = state.selectedWorklogId && String(state.selectedWorklogId) === r.id ? ' active' : '';
            const unlinked = !r.linkedCommentId ? ' unlinked' : '';
            const title = `${r.activity} | ${TimeService.jiraDuration(r.mins)} | ${r.author} | ${TimeService.dtLabel(r.startTs)}${r.linkedCommentId ? ` | Comentario ${r.linkedCommentId}` : ' | Sin comentario vinculado'}`;
            return `<span class="timeline-worklog-bar${active}${unlinked}" style="left:${left.toFixed(3)}%;width:${width.toFixed(3)}%;background:${escapeHtml(r.color)};" data-worklog-id="${escapeHtml(r.id)}" data-comment-id="${escapeHtml(r.linkedCommentId || '')}" data-activity="${escapeHtml(r.activity)}" data-minutes="${r.mins}" title="${escapeHtml(title)}"></span>`;
          }).join('');
          return `
            <div class="timeline-lane">
              <div class="timeline-lane-label${laneSelected ? ' chart-clickable' : ''}" data-activity="${escapeHtml(lane.activity)}" data-minutes="${lane.totalMinutes}">
                ${escapeHtml(lane.activity)} (${escapeHtml(TimeService.jiraDuration(lane.totalMinutes))})
              </div>
              <div class="timeline-lane-track">${bars}</div>
            </div>
          `;
        }).join('');

        el.timelineBox.className = '';
        el.timelineBox.innerHTML = `
          <div class="timeline-continuous">
            ${metaHtml}
            <div class="timeline-lane-list">
              ${commentLane}
              ${activityLanes || '<div class="chart-note">Aun no hay worklogs en el ticket.</div>'}
            </div>
          </div>
        `;
        el.ganttBox.className = 'hide';
        el.ganttBox.innerHTML = '';
        syncActivityFocusComponent();
      }

      function renderIssueData() {
        const key = state.selectedIssueKey;
        if (!key) {
          hideInlineRegistrar();
          hideInlineEditor();
          state.selectedCommentId = '';
          state.selectedWorklogId = '';
          renderComments('');
          renderWorklogs('');
          renderSuggestion('');
          renderTimeline('');
          return;
        }
        if (state.editCtx && state.editCtx.issueKey !== key) {
          hideInlineEditor();
        }
        if (state.regCtx && state.regCtx.issueKey !== key) {
          hideInlineRegistrar();
        }
        renderComments(key);
        renderWorklogs(key);
        renderSuggestion(key);
        renderTimeline(key);
      }

      function renderDashboard() {
        if (!FEATURES.dashboard) return;
        el.todayTotal.textContent = TimeService.jiraDuration(state.dash.today);
        el.weekTotal.textContent = TimeService.jiraDuration(state.dash.week);
        el.issueCount.textContent = String(state.dash.issueCount);
        el.dashMeta.textContent = state.dash.refreshedAt ? `Actualizado: ${TimeService.dtLabel(state.dash.refreshedAt)}` : 'Sin datos.';
        if (!state.dash.logs.length) {
          el.recentBox.className = 'empty';
          el.recentBox.textContent = 'Sin historial reciente.';
          return;
        }
        el.recentBox.className = '';
        el.recentBox.innerHTML = state.dash.logs.slice(0, 15).map((w) => {
          const line = `${w.issueKey} | ${activityOf(w)}`;
          const right = `${TimeService.jiraDuration(minutesOf(w))} - ${TimeService.dtLabel(w.started || w.created)}`;
          return `<div class="row" style="justify-content:space-between;border-bottom:1px solid #eef3f9;padding:6px 0;"><span class="recent-line">${escapeHtml(line)}</span><span class="muted">${escapeHtml(right)}</span></div>`;
        }).join('');
      }

      function normalizeSchool(summary) {
        const raw = String(summary || '').trim();
        if (!raw) return 'SIN_COLEGIO';
        const clean = raw.normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\[[^\]]+\]/g, ' ').replace(/\s+/g, ' ').trim().toUpperCase();
        if (!clean) return 'SIN_COLEGIO';
        return (clean.split(/\s*[-|:;/]\s*/)[0] || clean).slice(0, 80).trim() || 'SIN_COLEGIO';
      }

      function uniqueStrings(list) {
        const seen = new Set();
        const out = [];
        (list || []).forEach((v) => {
          const t = String(v || '').trim();
          if (!t) return;
          const k = t.toLowerCase();
          if (seen.has(k)) return;
          seen.add(k);
          out.push(t);
        });
        return out;
      }

      function xlsxTokens(text) {
        const src = String(text || '');
        const rg = /([A-Za-z0-9_\-./%() ]+\.xlsx)\b/gi;
        const out = [];
        let m = rg.exec(src);
        while (m) {
          out.push(m[1].trim());
          m = rg.exec(src);
        }
        return uniqueStrings(out);
      }

      function renderReport() {
        if (!FEATURES.report) return;
        const g = state.report.grouped || [];
        el.exportReportBtn.disabled = !g.length;
        if (!g.length) {
          el.reportBody.innerHTML = '<tr><td colspan="4"><div class="empty">Sin resultados.</div></td></tr>';
          if (!(state.report.detail || []).length) el.reportMeta.textContent = 'Sin reporte.';
          return;
        }
        el.reportBody.innerHTML = g.map((it) => `<tr><td>${escapeHtml(it.colegio)}</td><td>${it.tickets}</td><td>${it.comentarios}</td><td>${it.adjuntos_xlsx}</td></tr>`).join('');
        el.reportMeta.textContent = `Detalle detectado: ${state.report.detail.length} comentarios.`;
      }

      async function mapLimit(items, limit, fn) {
        const size = Math.max(1, Math.min(limit, items.length));
        let idx = 0;
        const workers = Array.from({ length: size }, async () => {
          while (true) {
            const cur = idx;
            idx += 1;
            if (cur >= items.length) break;
            await fn(items[cur], cur);
          }
        });
        await Promise.all(workers);
      }

      async function refreshDashboard() {
        if (!FEATURES.dashboard) {
          return;
        }
        if (!state.connected || !state.issues.length) {
          state.dash = { logs: [], today: 0, week: 0, issueCount: 0, refreshedAt: null };
          renderDashboard();
          return;
        }
        await mapLimit(state.issues.map((i) => i.key), 4, async (key) => {
          try {
            const payload = await JiraService.worklogs(key);
            const list = Array.isArray(payload.worklogs) ? payload.worklogs : [];
            state.worklogsByIssue[key] = sortDesc(list, (w) => w.started || w.created || '');
          } catch (_e) {
            if (!state.worklogsByIssue[key]) state.worklogsByIssue[key] = [];
          }
        });
        const all = [];
        const today = TimeService.startOfToday().getTime();
        const week = TimeService.startOfWeek().getTime();
        let todayMin = 0;
        let weekMin = 0;
        const issueSet = new Set();
        state.issues.forEach((issue) => {
          (state.worklogsByIssue[issue.key] || []).forEach((w) => {
            if (!mine(w.author)) return;
            const ts = new Date(w.started || w.created || 0).getTime();
            const mins = minutesOf(w);
            if (ts >= today) todayMin += mins;
            if (ts >= week) weekMin += mins;
            issueSet.add(issue.key);
            all.push(Object.assign({}, w, { issueKey: issue.key }));
          });
        });
        state.dash = {
          logs: sortDesc(all, (w) => w.started || w.created || ''),
          today: todayMin,
          week: weekMin,
          issueCount: issueSet.size,
          refreshedAt: new Date()
        };
        renderDashboard();
      }
      async function generateReport() {
        if (!FEATURES.report) {
          return;
        }
        if (!state.connected || !state.issues.length) {
          showMsg('error', 'No hay tickets cargados para generar reporte.');
          return;
        }
        showMsg('info', 'Generando reporte de comentarios...');
        const detail = [];
        await mapLimit(state.issues, 4, async (issue) => {
          let comments = state.commentsByIssue[issue.key];
          if (!comments) {
            try {
              const payload = await JiraService.comments(issue.key);
              comments = sortDesc(Array.isArray(payload.comments) ? payload.comments : [], (c) => c.created || '');
              state.commentsByIssue[issue.key] = comments;
            } catch (_e) {
              comments = [];
            }
          }
          const issueXlsx = uniqueStrings((issue.attachments || []).map((a) => (a && a.filename ? String(a.filename) : '')).filter((name) => /\.xlsx$/i.test(name)));
          comments.forEach((c) => {
            const text = commentText(c);
            if (!text.toLowerCase().includes('plantilla')) return;
            const merged = uniqueStrings([ ...xlsxTokens(text), ...issueXlsx ]);
            if (!merged.length) return;
            detail.push({
              colegio: normalizeSchool(issue.summary),
              issue_key: issue.key,
              issue_summary: issue.summary || '',
              comment_id: c.id,
              author: c.author && c.author.displayName ? c.author.displayName : '',
              created: TimeService.dtLabel(c.created),
              actividad_sugerida: activityFromText(text),
              adjuntos_xlsx: merged.join(' | '),
              comentario: text.replace(/\s+/g, ' ').trim().slice(0, 240)
            });
          });
        });
        const map = {};
        detail.forEach((row) => {
          const k = row.colegio || 'SIN_COLEGIO';
          if (!map[k]) map[k] = { colegio: k, ticketsSet: new Set(), comentarios: 0, adjuntos: 0 };
          map[k].ticketsSet.add(row.issue_key);
          map[k].comentarios += 1;
          map[k].adjuntos += String(row.adjuntos_xlsx || '').split('|').filter((x) => x.trim()).length;
        });
        const grouped = Object.values(map).map((it) => ({
          colegio: it.colegio,
          tickets: it.ticketsSet.size,
          comentarios: it.comentarios,
          adjuntos_xlsx: it.adjuntos
        })).sort((a, b) => b.comentarios - a.comentarios);
        state.report = { detail, grouped };
        renderReport();
        showMsg(detail.length ? 'ok' : 'info', detail.length ? `Reporte generado (${detail.length} comentarios detectados).` : 'No se detectaron comentarios con plantilla + .xlsx.');
      }

      function exportReport() {
        if (!FEATURES.report) {
          return;
        }
        if (!state.report.detail.length) {
          showMsg('error', 'Primero genera el reporte.');
          return;
        }
        if (!window.XLSX || !window.XLSX.utils) {
          showMsg('error', 'No se pudo cargar libreria XLSX en el navegador.');
          return;
        }
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(state.report.detail), 'Detalle');
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(state.report.grouped), 'PorColegio');
        const stamp = TimeService.toInputDate(new Date()).replace(/-/g, '');
        XLSX.writeFile(wb, `jira_reporte_plantillas_${stamp}.xlsx`);
      }

      async function loadIssueData(issueKey) {
        if (!issueKey) return;
        const [c, w] = await Promise.all([JiraService.comments(issueKey), JiraService.worklogs(issueKey)]);
        const comments = sortDesc(Array.isArray(c.comments) ? c.comments : [], (x) => x.created || '');
        const worklogs = sortDesc(Array.isArray(w.worklogs) ? w.worklogs : [], (x) => x.started || x.created || '');
        state.commentsByIssue[issueKey] = comments;
        state.worklogsByIssue[issueKey] = worklogs;
        renderIssueData();
      }

      async function loadIssues() {
        const payload = await JiraService.searchIssues();
        state.issues = parseIssues(payload);
        renderIssueSelect();
        if (state.selectedIssueKey) await loadIssueData(state.selectedIssueKey);
        else renderIssueData();
      }

      async function createWorklog(issueKey, activity, minutes, explicitStarted = null) {
        const key = String(issueKey || '').trim();
        const act = String(activity || '').trim();
        const mins = Math.max(0, Math.floor(Number(minutes || 0)));
        if (!key) { showMsg('error', 'Selecciona un ticket.'); return; }
        if (!act) { showMsg('error', 'Ingresa una actividad.'); return; }
        if (!mins) { showMsg('error', 'Duracion invalida.'); return; }
        const started = explicitStarted instanceof Date ? explicitStarted : TimeService.subtractBusinessMinutes(new Date(), mins);
        const payload = {
          started: TimeService.jiraDateTime(started),
          timeSpentSeconds: mins * 60,
          comment: toAdf(worklogCommentFromActivity(act, started))
        };
        await JiraService.addWorklog(key, payload);
        pushActivity(act);
        markActivity();
        timerReset();
        await loadIssueData(key);
        await refreshDashboard();
        showMsg('ok', `Worklog registrado (${TimeService.jiraDuration(mins)}).`);
      }

      async function updateWorklog(issueKey, worklogId, activity, dateObj, minutes) {
        const key = String(issueKey || '').trim();
        const id = String(worklogId || '').trim();
        const act = String(activity || '').trim();
        const mins = Math.max(0, Math.floor(Number(minutes || 0)));
        if (!key || !id || !act || !mins || !(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) {
          showMsg('error', 'Datos incompletos para editar worklog.');
          return;
        }
        const payload = {
          started: TimeService.jiraDateTime(dateObj),
          timeSpentSeconds: mins * 60,
          comment: toAdf(worklogCommentFromActivity(act, dateObj))
        };
        await JiraService.updateWorklog(key, id, payload);
        pushActivity(act);
        markActivity();
        await loadIssueData(key);
        await refreshDashboard();
        showMsg('ok', 'Worklog actualizado.');
      }

      async function deleteWorklog(issueKey, worklogId) {
        await JiraService.deleteWorklog(issueKey, worklogId);
        markActivity();
        await loadIssueData(issueKey);
        await refreshDashboard();
        showMsg('ok', 'Worklog eliminado.');
      }

      function readConfigInputs() {
        return {
          url: sanitizeUrl(el.urlInp.value),
          client_id: String(el.clientIdInp.value || '').trim(),
          client_secret: String(el.clientSecretInp.value || ''),
          redirect_uri: String(el.redirectUriInp.value || '').trim(),
          cloud_id: ''
        };
      }

      function applyConfigToInputs(cfg) {
        if (!cfg) return;
        el.urlInp.value = cfg.url || '';
        el.clientIdInp.value = cfg.client_id || '';
        el.clientSecretInp.value = cfg.client_secret || '';
        el.redirectUriInp.value = cfg.redirect_uri || deriveDefaultRedirectUri();
      }

      function isLikelyWrongRedirectUri(jiraUrl, redirectUri) {
        const jiraHost = safeHostname(jiraUrl);
        const redirectHost = safeHostname(redirectUri);
        if (!jiraHost || !redirectHost) return false;
        return jiraHost === redirectHost;
      }

      function resetConnectionState() {
        state.connected = false;
        state.config = null;
        state.me = null;
        state.issues = [];
        state.selectedIssueKey = '';
        state.commentsByIssue = {};
        state.worklogsByIssue = {};
        state.timelineLinksByIssue = {};
        state.selectedCommentId = '';
        state.selectedWorklogId = '';
        state.selectedTimelineActivity = '';
        state.selectedTimelineMinutes = 0;
        state.report = { detail: [], grouped: [] };
        state.dash = { logs: [], today: 0, week: 0, issueCount: 0, refreshedAt: null };
        JiraService.setCloudId('');
      }

      async function resolveCloudId(cfg, tokens) {
        if (cfg.cloud_id) {
          return cfg.cloud_id;
        }
        const resources = await OAuthService.getResources(tokens.access_token);
        dbg('oauth_resources_loaded', { count: resources.length });
        const resource = OAuthService.pickCloudResource(resources, cfg.url);
        const cloudId = String(resource.id || '').trim();
        if (!cloudId) {
          const err = new Error('No se pudo resolver cloudId para Jira.');
          err.kind = 'oauth';
          err.status = 404;
          throw err;
        }
        return cloudId;
      }

      async function connectWithStoredSession(cfg, persistConfig) {
        const effective = {
          url: sanitizeUrl(cfg.url || ''),
          client_id: String(cfg.client_id || '').trim(),
          client_secret: String(cfg.client_secret || ''),
          redirect_uri: String(cfg.redirect_uri || '').trim(),
          cloud_id: String(cfg.cloud_id || '').trim()
        };
        if (!effective.url || !effective.client_id || !effective.client_secret || !effective.redirect_uri) {
          const err = new Error('Configuracion OAuth incompleta.');
          err.kind = 'oauth';
          err.status = 400;
          throw err;
        }
        dbg('connect_with_session_start', {
          jira_host: safeHostname(effective.url),
          redirect_host: safeHostname(effective.redirect_uri),
          has_cloud_id: !!effective.cloud_id
        });
        const tokens = await OAuthService.ensureValidTokens(effective);
        if (!effective.cloud_id) {
          effective.cloud_id = await resolveCloudId(effective, tokens);
        }
        if (persistConfig) {
          StorageService.saveConfig(effective);
        }
        JiraService.setCloudId(effective.cloud_id);
        const me = await JiraService.myself();
        state.connected = true;
        state.config = effective;
        state.me = me;
        renderTop();
        await loadIssues();
        await refreshDashboard();
        dbg('connect_with_session_ok', { issue_count: state.issues.length });
      }

      async function processOAuthCallback(callbackUrl, clearTopUrl) {
        if (state.oauthCallbackInProgress) {
          dbg('oauth_callback_skip_in_progress');
          return false;
        }
        state.oauthCallbackInProgress = true;
        const params = parseUrlParams(callbackUrl);
        dbg('oauth_callback_detected', {
          has_code: !!params.code,
          has_error: !!params.error,
          clear_top_url: !!clearTopUrl
        });
        try {
          if (!params.code && !params.error) {
            return false;
          }
          if (params.error) {
            StorageService.clearOAuthPending();
            if (clearTopUrl) {
              clearOAuthParamsFromTopUrl();
            }
            const err = new Error(params.error_description || params.error);
            err.kind = 'oauth';
            err.status = 400;
            throw err;
          }
          const pending = StorageService.getOAuthPending();
          if (!pending) {
            if (StorageService.getOAuthTokens()) {
              dbg('oauth_callback_pending_missing_but_tokens_exist');
              if (clearTopUrl) {
                clearOAuthParamsFromTopUrl();
              }
              tryCloseOAuthPopup('callback_already_processed');
              return true;
            }
            const err = new Error('No hay estado OAuth pendiente. Inicia nuevamente la conexion.');
            err.kind = 'oauth';
            err.status = 400;
            throw err;
          }
          if (String(params.state || '') !== String(pending.state || '')) {
            StorageService.clearOAuthPending();
            const err = new Error('State OAuth invalido. Posible callback de otra sesion.');
            err.kind = 'oauth';
            err.status = 400;
            throw err;
          }
          const cfg = StorageService.getConfig();
          if (!cfg) {
            const err = new Error('No existe configuracion local para completar OAuth.');
            err.kind = 'oauth';
            err.status = 400;
            throw err;
          }
          const tokenPayload = await OAuthService.exchangeCode(cfg, params.code, String(pending.code_verifier || ''));
          StorageService.saveOAuthTokens(tokenPayload);
          StorageService.clearOAuthPending();
          dbg('oauth_callback_token_saved', { has_refresh: !!tokenPayload.refresh_token });
          if (clearTopUrl) {
            clearOAuthParamsFromTopUrl();
          }
          let postConnectError = null;
          try {
            await connectWithStoredSession(cfg, true);
          } catch (error) {
            postConnectError = error;
            dbg('oauth_callback_post_connect_error', {
              kind: error && error.kind ? error.kind : '',
              status: error && error.status ? error.status : '',
              message: error && error.message ? error.message : ''
            });
          }
          StorageService.markOAuthDone('callback');
          dbg('oauth_callback_completed', {
            connected: state.connected,
            has_post_error: !!postConnectError
          });
          tryCloseOAuthPopup('callback_completed');
          if (postConnectError) {
            throw postConnectError;
          }
          return true;
        } finally {
          state.oauthCallbackInProgress = false;
        }
      }

      function bind() {
        window.addEventListener('storage', async (event) => {
          if (!event || event.key !== STORAGE.oauthDone || !event.newValue) {
            return;
          }
          dbg('oauth_done_storage_event');
          if (state.connected) {
            return;
          }
          try {
            await autoReconnect();
          } catch (_e) {
            // autoReconnect already handles UI/errors
          }
        });

        el.debugClearBtn.addEventListener('click', () => {
          state.debugLogs = [];
          renderDebugLogs();
        });
        el.debugCopyBtn.addEventListener('click', async () => {
          const payload = (state.debugLogs || []).join('\n');
          try {
            await navigator.clipboard.writeText(payload);
            showMsg('info', 'Logs copiados al portapapeles.');
          } catch (_e) {
            showMsg('error', 'No se pudo copiar logs. Copia manual desde el panel.');
          }
        });

        el.connectBtn.addEventListener('click', async () => {
          clearMsg();
          const cfg = readConfigInputs();
          if (!cfg.redirect_uri) {
            cfg.redirect_uri = deriveDefaultRedirectUri();
            el.redirectUriInp.value = cfg.redirect_uri;
          }
          if (!cfg.url || !cfg.client_id || !cfg.client_secret || !cfg.redirect_uri) {
            showMsg('error', 'Completa URL Jira, Client ID, Client Secret y Redirect URI.');
            return;
          }
          if (isLikelyWrongRedirectUri(cfg.url, cfg.redirect_uri)) {
            showMsg(
              'error',
              'El Redirect URI no debe ser la URL de Jira. Usa la URL de esta app (la donde esta abierto este modulo) y registrala en Atlassian OAuth.'
            );
            dbg('oauth_invalid_redirect_uri', {
              jira_host: safeHostname(cfg.url),
              redirect_host: safeHostname(cfg.redirect_uri)
            });
            return;
          }
          StorageService.saveConfig(cfg);
          StorageService.clearOAuthTokens();
          StorageService.clearOAuthPending();
          StorageService.clearOAuthDone();
          clearPopupWatcher();
          const popupWindow = openOAuthPopupWindow();
          if (!popupWindow) {
            showMsg('error', 'El navegador bloqueo la ventana OAuth. Permite popups para este sitio e intenta de nuevo.');
            return;
          }
          try {
            await OAuthService.startAuth(cfg, popupWindow);
            watchOAuthPopupCallback(popupWindow, cfg);
            showMsg('info', 'Se abrio una nueva pestaña/ventana para autorizacion OAuth.');
          } catch (e) {
            try { popupWindow.close(); } catch (_closeErr) { /* ignore */ }
            clearPopupWatcher();
            applyError(e, 'No fue posible iniciar OAuth.');
          }
        });

        el.clearOAuthBtn.addEventListener('click', () => {
          clearPopupWatcher();
          StorageService.clearOAuthTokens();
          StorageService.clearOAuthPending();
          StorageService.clearOAuthDone();
          StorageService.del(STORAGE.config);
          resetConnectionState();
          renderTop();
          renderIssueSelect();
          renderIssueData();
          renderDashboard();
          renderReport();
          showMsg('info', 'Sesion OAuth local limpiada.');
        });

        el.processCallbackBtn.addEventListener('click', async () => {
          clearMsg();
          const raw = String(el.callbackUrlInp.value || '').trim();
          dbg('oauth_process_callback_clicked', { has_url: !!raw });
          if (!raw) {
            showMsg('error', 'Pega la URL completa de callback para procesarla.');
            return;
          }
          if (!StorageService.getConfig()) {
            const cfg = readConfigInputs();
            if (!cfg.redirect_uri) {
              cfg.redirect_uri = deriveDefaultRedirectUri();
              el.redirectUriInp.value = cfg.redirect_uri;
            }
            if (cfg.url && cfg.client_id && cfg.client_secret && cfg.redirect_uri) {
              StorageService.saveConfig(cfg);
            }
          }
          try {
            const processed = await processOAuthCallback(raw, false);
            if (!processed) {
              showMsg('error', 'La URL no contiene parametros OAuth (code/state/error). Pega la URL completa de retorno.');
              return;
            }
            showMsg('ok', 'Callback OAuth procesado correctamente.');
          } catch (e) {
            resetConnectionState();
            renderTop();
            applyError(e, 'No se pudo procesar el callback OAuth.');
          }
        });

        el.disconnectBtn.addEventListener('click', () => {
          clearPopupWatcher();
          StorageService.del(STORAGE.config);
          StorageService.clearOAuthTokens();
          StorageService.clearOAuthPending();
          StorageService.clearOAuthDone();
          resetConnectionState();
          renderTop();
          renderIssueSelect();
          renderIssueData();
          renderDashboard();
          renderReport();
          clearMsg();
        });

        el.refreshIssuesBtn.addEventListener('click', async () => {
          if (!state.connected) return;
          try { await loadIssues(); await refreshDashboard(); showMsg('ok', 'Tickets actualizados.'); }
          catch (e) { applyError(e, 'No se pudieron recargar tickets.'); }
        });

        el.issueSel.addEventListener('change', async () => {
          state.selectedIssueKey = String(el.issueSel.value || '');
          uiStateSave();
          if (!state.selectedIssueKey) { renderIssueData(); return; }
          try { await loadIssueData(state.selectedIssueKey); }
          catch (e) { applyError(e, `No se pudo cargar detalle de ${state.selectedIssueKey}.`); }
          renderCompact();
        });

        el.activityTypeSel.addEventListener('change', () => {
          syncOfficialActivityToState(true);
        });
        el.activityDueInp.addEventListener('change', () => {
          syncOfficialActivityToState(true);
        });
        el.minutesInp.addEventListener('input', () => {
          state.durationMinutes = Math.max(1, Math.floor(Number(el.minutesInp.value || 0)));
          el.minutesInp.value = String(state.durationMinutes);
          uiStateSave();
          renderDurationPill();
        });
        el.activityQuickSel.addEventListener('change', () => {
          const selectedType = OFFICIAL_ACTIVITY_TYPES.includes(String(el.activityQuickSel.value || '').trim())
            ? String(el.activityQuickSel.value || '').trim()
            : OFFICIAL_ACTIVITY_TYPES[0];
          state.activityType = selectedType;
          el.activityTypeSel.value = selectedType;
          syncOfficialActivityToState(true);

          const key = state.selectedIssueKey;
          const logs = state.worklogsByIssue[key] || [];
          const grouped = {};
          logs.forEach((w) => {
            const act = activityOf(w);
            const mapped = inferOfficialActivityType(act);
            if (mapped !== selectedType) return;
            if (!grouped[act]) grouped[act] = 0;
            grouped[act] += minutesOf(w);
          });
          const match = Object.entries(grouped).sort((a, b) => b[1] - a[1])[0] || null;
          if (match) {
            selectActivityFromCharts(match[0], match[1], true);
          } else {
            state.selectedTimelineActivity = selectedType;
            state.selectedTimelineMinutes = 0;
            syncActivityFocusComponent();
            renderTimeline(state.selectedIssueKey);
          }
        });
        el.editTypeSel.addEventListener('change', () => {
          syncEditActivityPreview();
        });
        el.editDateInp.addEventListener('change', () => {
          syncEditActivityPreview();
        });
        el.regTypeSel.addEventListener('change', () => {
          syncInlineRegistrarInputs();
        });
        el.regDateInp.addEventListener('change', () => {
          syncInlineRegistrarInputs();
        });
        el.chartDesignSel.addEventListener('change', () => {
          const selected = String(el.chartDesignSel.value || '').trim();
          state.chartDesign = CHART_DESIGNS.some((d) => d.id === selected)
            ? selected
            : DEFAULT_CHART_DESIGN;
          applyChartDesign();
          uiStateSave();
          renderTimeline(state.selectedIssueKey);
        });

        el.registerBtn.addEventListener('click', async () => {
          syncOfficialActivityToState(false);
          if (!parseOfficialActivity(state.activity)) {
            showMsg('error', 'Selecciona un tipo de actividad oficial y una fecha fin valida.');
            return;
          }
          state.durationMinutes = Math.max(1, Math.floor(Number(el.minutesInp.value || 0)));
          uiStateSave();
          renderDurationPill();
          try { await createWorklog(state.selectedIssueKey, state.activity, state.durationMinutes); }
          catch (e) { applyError(e, 'No se pudo registrar worklog.'); }
        });

        el.startBtn.addEventListener('click', timerStart);
        el.pauseBtn.addEventListener('click', timerPause);
        el.resetBtn.addEventListener('click', timerReset);
        el.applyTimerBtn.addEventListener('click', () => {
          applyTimerToMinutes();
          showMsg('info', `Duracion tomada del timer: ${TimeService.jiraDuration(state.durationMinutes)}.`);
        });

        el.applySugActBtn.addEventListener('click', () => {
          if (!state.suggestion) return;
          const suggested = String(state.suggestion.activityType || state.suggestion.activity || '').trim();
          state.activityType = OFFICIAL_ACTIVITY_TYPES.includes(suggested)
            ? suggested
            : inferOfficialActivityType(suggested);
          const suggestedDate = TimeService.toInputDate(state.suggestion.created || new Date());
          state.activityDueDate = isValidInputDate(suggestedDate)
            ? suggestedDate
            : TimeService.toInputDate(new Date());
          el.activityTypeSel.value = state.activityType;
          if (isValidInputDate(state.activityDueDate)) {
            el.activityDueInp.value = state.activityDueDate;
          }
          syncOfficialActivityToState(true);
        });

        el.applySugTimeBtn.addEventListener('click', () => {
          if (!state.suggestion) return;
          state.durationMinutes = state.suggestion.minutes;
          el.minutesInp.value = String(state.durationMinutes);
          uiStateSave();
          renderDurationPill();
        });
        el.registerSugBtn.addEventListener('click', async () => {
          if (!state.suggestion) return;
          if (!state.selectedIssueKey) {
            showMsg('error', 'Selecciona un ticket para registrar la sugerencia.');
            return;
          }
          const suggested = String(state.suggestion.activityType || state.suggestion.activity || '').trim();
          state.activityType = OFFICIAL_ACTIVITY_TYPES.includes(suggested)
            ? suggested
            : inferOfficialActivityType(suggested);
          const suggestedDate = TimeService.toInputDate(state.suggestion.created || new Date());
          state.activityDueDate = isValidInputDate(suggestedDate)
            ? suggestedDate
            : TimeService.toInputDate(new Date());
          state.activity = buildOfficialActivity(state.activityType, state.activityDueDate);
          state.durationMinutes = Math.max(1, Math.floor(Number(state.suggestion.minutes || 0)));
          el.activityTypeSel.value = state.activityType;
          el.activityDueInp.value = state.activityDueDate;
          el.activityInp.value = state.activity;
          el.minutesInp.value = String(state.durationMinutes);
          renderDurationPill();
          uiStateSave();
          try { await createWorklog(state.selectedIssueKey, state.activity, state.durationMinutes); }
          catch (e) { applyError(e, 'No se pudo registrar la sugerencia.'); }
        });

        el.timelineBox.addEventListener('click', (ev) => {
          const node = ev.target.closest('[data-worklog-id], [data-comment-id], [data-activity]');
          if (!node) return;
          const activity = String(node.getAttribute('data-activity') || '').trim();
          const mins = Number(node.getAttribute('data-minutes') || 0);
          const worklogId = String(node.getAttribute('data-worklog-id') || '').trim();
          const commentId = String(node.getAttribute('data-comment-id') || '').trim();
          if (worklogId || commentId) {
            focusTimelineSelection(state.selectedIssueKey, commentId, worklogId, activity, mins);
            return;
          }
          if (!activity) return;
          selectActivityFromCharts(activity, mins, true);
        });
        el.ganttBox.addEventListener('click', (ev) => {
          const node = ev.target.closest('[data-activity]');
          if (!node) return;
          const activity = String(node.getAttribute('data-activity') || '').trim();
          const mins = Number(node.getAttribute('data-minutes') || 0);
          if (!activity) return;
          selectActivityFromCharts(activity, mins, true);
        });

        if (FEATURES.dashboard) {
          el.refreshDashBtn.addEventListener('click', async () => {
            try { await refreshDashboard(); showMsg('ok', 'Dashboard actualizado.'); }
            catch (e) { applyError(e, 'No se pudo actualizar dashboard.'); }
          });
        }

        if (FEATURES.report) {
          el.genReportBtn.addEventListener('click', async () => {
            try { await generateReport(); }
            catch (e) { applyError(e, 'No se pudo generar reporte.'); }
          });
          el.exportReportBtn.addEventListener('click', exportReport);
        }

        el.commentsBox.addEventListener('click', (ev) => {
          const btn = ev.target;
          if (!btn || btn.dataset.act !== 'reg-from-comment') return;
          const commentId = btn.dataset.id;
          const comments = state.commentsByIssue[state.selectedIssueKey] || [];
          const c = comments.find((x) => String(x.id) === String(commentId));
          if (!c) return;
          const mins = Math.max(5, Math.min(480, TimeService.businessMinutesBetween(new Date(c.created), new Date())));
          state.regCtx = { issueKey: state.selectedIssueKey, commentId: String(c.id) };
          const inferredType = inferOfficialActivityType(commentText(c));
          const inferredDue = TimeService.toInputDate(c.created || new Date());
          el.regTypeSel.value = OFFICIAL_ACTIVITY_TYPES.includes(inferredType)
            ? inferredType
            : OFFICIAL_ACTIVITY_TYPES[0];
          el.regDateInp.value = isValidInputDate(inferredDue)
            ? inferredDue
            : TimeService.toInputDate(new Date());
          el.regMinInp.value = String(mins);
          el.regInlineMeta.textContent = `${state.selectedIssueKey} | ${TimeService.dtLabel(c.created)}`;
          syncInlineRegistrarInputs();
          showInlineRegistrar();
        });
        el.commentsBox.addEventListener('click', (ev) => {
          const target = ev.target;
          if (target.closest('button')) return;
          const card = target.closest('.comment[data-comment-id]');
          if (!card) return;
          const commentId = String(card.getAttribute('data-comment-id') || '').trim();
          if (!commentId) return;
          const key = state.selectedIssueKey;
          if (!key) return;
          const links = state.timelineLinksByIssue[key] || { commentToWorklogIds: {} };
          const worklogIds = links.commentToWorklogIds && links.commentToWorklogIds[commentId]
            ? links.commentToWorklogIds[commentId]
            : [];
          const worklogId = worklogIds.length ? String(worklogIds[0]) : '';
          let activity = '';
          let mins = 0;
          if (worklogId) {
            const worklogs = state.worklogsByIssue[key] || [];
            const w = worklogs.find((x) => String(x.id) === worklogId);
            if (w) {
              activity = activityOf(w);
              mins = minutesOf(w);
            }
          }
          focusTimelineSelection(key, commentId, worklogId, activity, mins);
        });

        el.regInlineCancelBtn.addEventListener('click', () => { hideInlineRegistrar(); });
        el.regInlineOkBtn.addEventListener('click', async () => {
          if (!state.regCtx) { hideInlineRegistrar(); return; }
          const issueKey = state.regCtx.issueKey;
          syncInlineRegistrarInputs();
          const activity = buildOfficialActivity(String(el.regTypeSel.value || '').trim(), String(el.regDateInp.value || '').trim());
          const mins = Math.max(1, Math.floor(Number(el.regMinInp.value || 0)));
          if (!parseOfficialActivity(activity)) {
            showMsg('error', 'La actividad debe usar formato oficial: [Tipo de actividad] [DD/MM/AAAA].');
            return;
          }
          hideInlineRegistrar();
          try { await createWorklog(issueKey, activity, mins); }
          catch (e) { applyError(e, 'No se pudo registrar actividad desde comentario.'); }
        });

        el.worklogBody.addEventListener('click', async (ev) => {
          const btn = ev.target;
          if (!btn || !btn.dataset.act) return;
          const action = btn.dataset.act;
          const id = btn.dataset.id;
          const key = state.selectedIssueKey;
          if (!key || !id) return;
          const worklogs = state.worklogsByIssue[key] || [];
          const w = worklogs.find((x) => String(x.id) === String(id));
          if (!w) return;
          if (action === 'view-worklog') {
            focusWorklogInDashboard(key, w);
            return;
          }
          if (action === 'edit-worklog') {
            state.editCtx = { issueKey: key, id: String(id) };
            const d = new Date(w.started || w.created || new Date());
            el.editMeta.textContent = `${key} | Worklog ${id}`;
            const currentAct = activityOf(w);
            const parsed = parseOfficialActivity(currentAct);
            const inferredType = parsed && OFFICIAL_ACTIVITY_TYPES.includes(parsed.type)
              ? parsed.type
              : inferOfficialActivityType(currentAct);
            el.editTypeSel.value = OFFICIAL_ACTIVITY_TYPES.includes(inferredType)
              ? inferredType
              : OFFICIAL_ACTIVITY_TYPES[0];
            el.editDateInp.value = TimeService.toInputDate(d);
            el.editTimeInp.value = TimeService.toInputTime(d);
            el.editMinInp.value = String(minutesOf(w));
            syncEditActivityPreview();
            showInlineEditor();
          }
          if (action === 'del-worklog') {
            if (!window.confirm(`Eliminar worklog ${id}?`)) return;
            try { await deleteWorklog(key, id); }
            catch (e) { applyError(e, 'No se pudo eliminar worklog.'); }
          }
        });
        el.worklogBody.addEventListener('click', (ev) => {
          const target = ev.target;
          if (target.closest('button')) return;
          const row = target.closest('tr[data-worklog-id]');
          if (!row) return;
          const id = String(row.getAttribute('data-worklog-id') || '').trim();
          if (!id) return;
          const key = state.selectedIssueKey;
          if (!key) return;
          const worklogs = state.worklogsByIssue[key] || [];
          const w = worklogs.find((x) => String(x.id) === id);
          if (!w) return;
          focusWorklogInDashboard(key, w);
        });

        el.editCancelBtn.addEventListener('click', () => { hideInlineEditor(); });
        el.editSaveBtn.addEventListener('click', async () => {
          if (!state.editCtx) { hideInlineEditor(); return; }
          syncEditActivityPreview();
          const act = String(el.editActInp.value || '').trim();
          const mins = Math.max(1, Math.floor(Number(el.editMinInp.value || 0)));
          const date = String(el.editDateInp.value || '');
          const time = String(el.editTimeInp.value || '08:30');
          const dt = new Date(`${date}T${time}:00`);
          if (!act || !date || Number.isNaN(dt.getTime()) || !mins) { showMsg('error', 'Completa actividad, fecha, hora y duracion.'); return; }
          if (!parseOfficialActivity(act)) { showMsg('error', 'Selecciona una actividad oficial y fecha valida.'); return; }
          const { issueKey, id } = state.editCtx;
          hideInlineEditor();
          try { await updateWorklog(issueKey, id, act, dt, mins); }
          catch (e) { applyError(e, 'No se pudo actualizar worklog.'); }
        });

        el.editDeleteBtn.addEventListener('click', async () => {
          if (!state.editCtx) return;
          const { issueKey, id } = state.editCtx;
          hideInlineEditor();
          if (!window.confirm(`Eliminar worklog ${id}?`)) return;
          try { await deleteWorklog(issueKey, id); }
          catch (e) { applyError(e, 'No se pudo eliminar worklog.'); }
        });

        el.compactBtn.addEventListener('click', () => {
          state.compact = !state.compact;
          uiStateSave();
          renderCompact();
        });
        el.floatExpandBtn.addEventListener('click', () => {
          state.compact = false;
          uiStateSave();
          renderCompact();
        });
        el.floatStartBtn.addEventListener('click', timerStart);
        el.floatPauseBtn.addEventListener('click', timerPause);
      }

      async function autoReconnect() {
        dbg('auto_reconnect_start');
        clearPopupWatcher();
        const defaultRedirectUri = deriveDefaultRedirectUri();
        if (!el.redirectUriInp.value && defaultRedirectUri) {
          el.redirectUriInp.value = defaultRedirectUri;
        }

        const cfg = StorageService.getConfig();
        if (cfg) {
          applyConfigToInputs(cfg);
        }

        const topHref = getTopLocationHref();
        if (topHref) {
          el.callbackUrlInp.value = topHref;
        }
        const params = parseUrlParams(topHref);
        if (params.code || params.error) {
          dbg('auto_reconnect_callback_in_url', { has_code: !!params.code, has_error: !!params.error });
          try {
            await processOAuthCallback(topHref, true);
            showMsg('ok', 'Sesion OAuth iniciada correctamente.');
            return;
          } catch (e) {
            resetConnectionState();
            renderTop();
            applyError(e, 'No se pudo completar OAuth al volver de Atlassian.');
            return;
          }
        }

        if (!cfg) {
          renderTop();
          return;
        }

        try {
          await connectWithStoredSession(cfg, false);
          showMsg('ok', 'Reconectado automaticamente.');
        } catch (e) {
          resetConnectionState();
          renderTop();
          if (e && e.kind === 'oauth' && e.status === 401) {
            showMsg('info', 'Conecta con OAuth para iniciar sesion en Jira.');
          } else {
            applyError(e, 'No se pudo reconectar automaticamente.');
          }
        }
      }

      function bootstrap() {
        dbg('bootstrap_start', {
          in_iframe: window.self !== window.top,
          top_href_available: !!getTopLocationHref()
        });
        cacheElements();
        bind();
        uiStateLoad();
        timerLoad();

        renderOfficialActivityControls();
        syncActivityFocusComponent();
        applyChartDesign();
        hideInlineRegistrar();
        hideInlineEditor();
        el.minutesInp.value = String(state.durationMinutes);
        renderActivitiesList();
        renderDurationPill();
        renderTop();
        renderIssueData();
        renderDashboard();
        renderReport();
        renderTimer();
        renderCompact();
        renderIdle();
        renderDebugLogs();

        window.setInterval(() => { renderTimer(); renderCompact(); renderIdle(); }, 1000);
        window.setInterval(renderIdle, 60000);

        autoReconnect();
      }

      bootstrap();
    })();
  </script>
</body>
</html>

